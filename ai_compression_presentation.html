<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Next Algorithms: Knowledge Compression & Adaptive Complexity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Prevent text selection in navigation elements */
        .navigation, button {
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            color: #e0e0ff;
            overflow: hidden;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .presentation {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .slide {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0.8rem 1.2rem;
            position: relative;
            opacity: 0;
            animation: fadeIn 1s forwards;
        }
        
        /* Base grid layout for all slide content */
        .slide-content {
            width: 100%;
            max-width: 1300px;
            display: grid;
            gap: 1.2rem;
            align-items: start;
            margin: 0 auto;
        }
        
        /* Two-column layout explicitly for slides 2-6 */
        #slide2 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }
        
        #slide3 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }
        
        #slide4 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }
        
        #slide5 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }
        
        #slide6 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }
        
        /* Single column only for title slide */
        #slide1 .slide-content,
        .slide-content.single-column {
            grid-template-columns: 1fr !important;
            max-width: 1200px;
        }
        
        /* Debug: Ensure left and right panels are visible as columns */
        .slide:not(#slide1) .left-panel,
        .slide:not(#slide1) .right-panel {
            min-width: 0;
            width: 100%;
        }
        
        /* Visual separator for two-column layout */
        .slide:not(#slide1) .left-panel {
            padding-right: 1.5rem;
            position: relative;
            border-right: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .slide:not(#slide1) .right-panel {
            padding-left: 1.5rem;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        h1 {
            font-size: clamp(1.8rem, 3.5vw, 3rem);
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 1.2rem;
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        h2 {
            font-size: clamp(1.1rem, 1.8vw, 1.6rem);
            color: #a78bfa;
            margin-bottom: 0.6rem;
            text-align: left;
        }

        .visualization {
            width: 100%;
            height: 320px;
            margin: 0.6rem 0;
            background: rgba(30, 30, 50, 0.8);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-sizing: border-box;
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        button {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .info-box {
            background: rgba(30, 30, 50, 0.6);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1rem auto;
            max-width: 700px;
            backdrop-filter: blur(10px);
        }

        .parameter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            padding: 0.5rem;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .parameter label {
            font-weight: 500;
            color: #a78bfa;
        }

        .parameter span {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .compression-comparison {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.6rem;
            margin: 0.6rem 0;
            width: 100%;
        }

        .comparison-box {
            padding: 0.7rem;
            background: rgba(30, 30, 50, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            font-size: 0.85rem;
            width: 100%;
            box-sizing: border-box;
        }

        .comparison-box h3 {
            color: #f093fb;
            margin-bottom: 0.4rem;
            font-size: 0.95rem;
        }
        
        .comparison-box ul {
            margin: 0;
            padding-left: 1.2rem;
        }
        
        .comparison-box p {
            margin: 0.2rem 0;
        }

        .stats {
            font-family: 'Courier New', monospace;
            color: #a78bfa;
            font-size: 1.2rem;
            margin: 0.5rem 0;
        }

        .slider-container {
            margin: 0.8rem 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 0.5rem;
            color: #a78bfa;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: rgba(102, 126, 234, 0.3);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            cursor: pointer;
        }

        .navigation {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            gap: 0.8rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 1s ease;
            pointer-events: none;
        }
        
        .navigation.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .navigation.visible .nav-btn {
            animation: gentlePulse 2s ease-in-out 1;
        }
        
        @keyframes gentlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .nav-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }

        .quote {
            font-style: italic;
            color: #a78bfa;
            margin: 1.5rem auto;
            max-width: 600px;
            padding: 1rem;
            border-left: 4px solid #667eea;
            background: rgba(30, 30, 50, 0.4);
        }

        .highlight {
            color: #a78bfa;
            font-weight: bold;
        }
        
        ul {
            font-size: 0.85rem;
        }
        
        li {
            margin: 0.15rem 0;
        }
        
        p {
            margin: 0.4rem 0;
            line-height: 1.4;
            word-wrap: break-word;
        }
        
        /* Ensure two-column layout for content slides */
        #slide2 .slide-content,
        #slide3 .slide-content,
        #slide4 .slide-content,
        #slide5 .slide-content,
        #slide6 .slide-content {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
        }
        
        @media (max-width: 1200px) {
            .slide-content {
                gap: 0.8rem;
            }
            
            .visualization {
                height: 280px;
            }
        }
        
        @media (max-width: 1024px) {
            .slide:not(#slide1) .slide-content {
                grid-template-columns: 1fr !important;
                gap: 1.5rem;
            }
            
            .slide:not(#slide1) .left-panel {
                padding-right: 0;
                border-right: none;
            }
            
            .slide:not(#slide1) .right-panel {
                padding-left: 0;
            }
            
            .visualization {
                height: 300px;
            }
        }
        
        @media (max-width: 768px) {
            .navigation {
                bottom: 1rem;
                right: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="presentation">
        <!-- Slide 1: Title -->
        <div class="slide" id="slide1">
            <div class="slide-content single-column">
                <div style="text-align: center;">
                    <h1>The Next Algorithms</h1>
                    <h2 style="text-align: center;">Knowledge Compression & Adaptive Complexity</h2>
                    <div class="quote">
                        "AGI is just a few more algorithms away..."
                    </div>
                    <p style="margin-top: 2rem; font-size: 1.2rem;">
                        Two fundamental ideas that could transform how AI understands and interacts with the world
                    </p>
                    <p id="navHint" style="margin-top: 3rem; font-size: 0.9rem; color: #a78bfa; opacity: 0; transition: opacity 1.5s ease;">
                        Navigate with arrow keys or → button
                    </p>
                </div>
            </div>
        </div>

        <!-- Slide 2: Knowledge Compression Introduction -->
        <div class="slide" id="slide2" style="display: none;">
            <div class="content">
                <h2>Idea 1: Knowledge Compression</h2>
                <div class="info-box">
                    <p>Complex patterns can be represented with minimal information when we understand their underlying structure.</p>
                    <p style="margin-top: 1rem;">Example: <span class="highlight">1000 equilateral triangles</span> on a screen.</p>
                    <p style="margin-top: 0.5rem; color: #a78bfa;">
                        The same visual information can be stored as either 6000 coordinates<br>
                        or ~10 parameters that describe the pattern.
                    </p>
                </div>
                
                <div class="visualization">
                    <canvas id="triangleCanvas"></canvas>
                </div>
                
                <div class="compression-comparison">
                    <div class="comparison-box">
                        <h3>Traditional Storage</h3>
                        <p>Store every vertex position</p>
                        <div class="stats">6000 numbers</div>
                        <p style="font-size: 0.9rem; margin-top: 0.5rem;">
                            (1000 triangles × 3 vertices × 2 coordinates)
                        </p>
                        <p style="color: #a78bfa; margin-top: 1rem; font-size: 0.9rem;">
                            • Large storage requirement<br>
                            • No pattern understanding
                        </p>
                    </div>
                    <div class="comparison-box">
                        <h3>Compressed Representation</h3>
                        <p>Store pattern parameters</p>
                        <div class="stats">~10 numbers</div>
                        <ul style="text-align: left; margin-top: 0.5rem; font-size: 0.9rem;">
                            <li>Triangle size</li>
                            <li>Count</li>
                            <li>Distribution randomness</li>
                            <li>Average spacing</li>
                            <li>Color parameters</li>
                        </ul>
                        <p style="color: #a78bfa; margin-top: 1rem; font-size: 0.9rem;">
                            • Same visual result<br>
                            • 600:1 compression ratio
                        </p>
                    </div>
                </div>
                
                <div class="controls">
                    <button onclick="regenerateTriangles()">Regenerate Pattern</button>
                    <button onclick="toggleCompression()">Toggle: Raw Storage vs Compressed</button>
                </div>
            </div>
        </div>

        <!-- Slide 3: Orthogonal Representation -->
        <div class="slide" id="slide3" style="display: none;">
            <div class="slide-content">
                <div class="left-panel">
                    <h2>Orthogonal Representation</h2>
                    <div class="info-box">
                        <p>Every aspect of a system that is <span class="highlight">orthogonal</span> (independent) can be represented separately.</p>
                        <p style="margin-top: 1rem;">Similar to eigenvectors - finding the most efficient basis for representing information.</p>
                    </div>
                    
                    <div class="parameter">
                        <label>Color Dimension:</label>
                        <span id="colorValue" style="color: #a78bfa;">RGB(120, 80, 200)</span>
                    </div>
                    <div class="parameter">
                        <label>Size Dimension:</label>
                        <span id="sizeValue" style="color: #a78bfa;">15.3 units</span>
                    </div>
                    <div class="parameter">
                        <label>Pattern Frequency:</label>
                        <span id="frequencyValue" style="color: #a78bfa;">0.73</span>
                    </div>
                    <div class="parameter">
                        <label>Spatial Distribution:</label>
                        <span id="spatialValue" style="color: #a78bfa;">Gaussian(μ=0.5, σ=0.2)</span>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="visualization">
                        <canvas id="eigenCanvas"></canvas>
                    </div>
                    
                    <div class="controls">
                        <button onclick="animateEigenDecomposition()">Show Decomposition</button>
                        <button onclick="reconstructFromEigen()">Reconstruct</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Level of Detail -->
        <div class="slide" id="slide4" style="display: none;">
            <div class="content">
                <h2>Idea 2: Adaptive Level of Detail</h2>
                <div class="info-box">
                    <p>Part of intelligence means knowing <span class="highlight">what level of detail</span> you need to solve a problem.</p>
                    <p style="margin-top: 1rem;">Dial complexity up or down based on the task at hand.</p>
                </div>
                
                <div class="visualization">
                    <canvas id="lodCanvas"></canvas>
                </div>
                
                <div class="slider-container">
                    <label>Detail Level: <span id="lodValue">5</span></label>
                    <input type="range" id="lodSlider" min="1" max="10" value="5" oninput="updateLOD(this.value)">
                </div>
                
                <div class="info-box" style="margin-top: 2rem;">
                    <h3 id="lodTitle">Medium Detail</h3>
                    <p id="lodDescription">Modeling with ~1,000 parameters. Suitable for general pattern recognition.</p>
                    <div class="parameter">
                        <label>Parameters Used:</label>
                        <span id="paramCount" style="color: #a78bfa;">1,000</span>
                    </div>
                    <div class="parameter">
                        <label>Compression Ratio:</label>
                        <span id="compressionRatio" style="color: #a78bfa;">100:1</span>
                    </div>
                </div>
                
                <div class="controls">
                    <button onclick="simulateProblem('simple')">Task: Identify Species</button>
                    <button onclick="simulateProblem('complex')">Task: Analyze Cell Structure</button>
                    <button onclick="autoAdapt()">Auto-Adapt to Task</button>
                </div>
            </div>
        </div>

        <!-- Slide 5: Biological Example -->
        <div class="slide" id="slide5" style="display: none;">
            <div class="slide-content">
                <div class="left-panel">
                    <h2>Real-World Application: Modeling a Cell</h2>
                    <div class="info-box">
                        <p>From <span class="highlight">billions of DNA base pairs</span> to <span class="highlight">~10,000 numbers</span></p>
                        <p style="margin-top: 1rem;">Adjusting detail level based on the specific problem being solved.</p>
                    </div>
                    
                    <div class="compression-comparison">
                        <div class="comparison-box">
                            <h3>Problem: Cell Type Identification</h3>
                            <p>Parameters needed: <span class="stats">100-1,000</span></p>
                            <ul style="text-align: left; font-size: 0.85rem;">
                                <li>Membrane shape</li>
                                <li>Nucleus size/position</li>
                                <li>Major organelle distribution</li>
                            </ul>
                        </div>
                        <div class="comparison-box">
                            <h3>Problem: Metabolic Pathway Analysis</h3>
                            <p>Parameters needed: <span class="stats">10,000-100,000</span></p>
                            <ul style="text-align: left; font-size: 0.85rem;">
                                <li>Protein conformations</li>
                                <li>ATP/ADP ratios</li>
                                <li>Enzyme kinetics</li>
                                <li>DNA transcription factors</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="visualization">
                        <canvas id="cellCanvas"></canvas>
                    </div>
                    
                    <div class="controls">
                        <button onclick="zoomToCell()">View: Whole Cell</button>
                        <button onclick="zoomToOrganelle()">View: Organelle Detail</button>
                        <button onclick="zoomToMolecular()">View: Molecular Level</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 6: The Future -->
        <div class="slide" id="slide6" style="display: none;">
            <div class="slide-content">
                <div class="left-panel">
                    <h2>The Path to AGI</h2>
                    <div class="info-box">
                        <p>Combine <span class="highlight">optimal compression</span> with <span class="highlight">adaptive complexity</span></p>
                        <p style="margin-top: 1rem;">Result: AI that can efficiently model any system at the right level of detail</p>
                    </div>
                    
                    <div class="comparison-box">
                        <h3>Current AI (LLMs)</h3>
                        <ul style="text-align: left;">
                            <li>Brute force compression</li>
                            <li>Billions of parameters</li>
                            <li>Fixed level of detail</li>
                            <li>Context-limited understanding</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-box" style="margin-top: 1rem;">
                        <h3>Next-Gen AI</h3>
                        <ul style="text-align: left;">
                            <li>Optimal orthogonal representation</li>
                            <li>Dynamic parameter allocation</li>
                            <li>Adaptive detail levels</li>
                            <li>On-demand model creation</li>
                        </ul>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="info-box">
                        <h3>Key Innovations Needed</h3>
                        <ul style="text-align: left; list-style: none;">
                            <li>• Training models to find optimal compressions</li>
                            <li>• Agents that create models on-demand</li>
                            <li>• Dynamic complexity adjustment based on feedback</li>
                            <li>• Integration of multiple representation levels</li>
                        </ul>
                    </div>
                    
                    <div class="info-box" style="margin-top: 1rem;">
                        <h3>The Vision</h3>
                        <p>With these algorithms in place, the path to AGI becomes clearer.</p>
                        <p style="margin-top: 0.5rem;">The combination of optimal knowledge compression and adaptive complexity could enable AI systems that truly understand and model the world at any required level of detail.</p>
                        <p style="margin-top: 0.8rem; font-style: italic; color: #a78bfa;">
                            "When you see how you can go from billions of DNA pairs to just 10k numbers that describe the same complexity... it's pretty crazy."
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="navigation">
            <button class="nav-btn" onclick="previousSlide()">←</button>
            <button class="nav-btn" onclick="nextSlide()">→</button>
            <button class="nav-btn restart-btn" onclick="location.reload()" style="display: none; opacity: 0;" title="Restart Presentation">⟲</button>
        </div>
    </div>

    <script>
        // Ensure console methods exist to prevent errors
        if (typeof console === 'undefined') {
            window.console = { log: function() {}, debug: function() {} };
        } else {
            if (!console.debug) console.debug = console.log || function() {};
        }
        
        let currentSlide = 1;
        const totalSlides = 6;
        let compressionView = false;
        let triangles = [];
        let animationFrame;
        let navigationTimeout;

        function nextSlide() {
            if (currentSlide < totalSlides) {
                if (navigationTimeout) {
                    clearTimeout(navigationTimeout);
                    navigationTimeout = null;
                }
                document.getElementById(`slide${currentSlide}`).style.display = 'none';
                currentSlide++;
                const nextSlideEl = document.getElementById(`slide${currentSlide}`);
                nextSlideEl.style.display = 'flex';
                nextSlideEl.style.opacity = '0';
                setTimeout(() => nextSlideEl.style.opacity = '1', 10);
                initializeSlide(currentSlide);
                updateNavButtons();
                // Show navigation immediately on other slides
                showNavigation();
            }
        }

        function previousSlide() {
            if (currentSlide > 1) {
                if (navigationTimeout) {
                    clearTimeout(navigationTimeout);
                    navigationTimeout = null;
                }
                document.getElementById(`slide${currentSlide}`).style.display = 'none';
                currentSlide--;
                const prevSlideEl = document.getElementById(`slide${currentSlide}`);
                prevSlideEl.style.display = 'flex';
                prevSlideEl.style.opacity = '0';
                setTimeout(() => prevSlideEl.style.opacity = '1', 10);
                initializeSlide(currentSlide);
                updateNavButtons();
                // Show navigation immediately when going back
                showNavigation();
            }
        }
        
        function showNavigation() {
            const nav = document.querySelector('.navigation');
            if (nav) {
                nav.classList.add('visible');
            }
            // Also show the navigation hint on first slide
            if (currentSlide === 1) {
                const hint = document.getElementById('navHint');
                if (hint) {
                    hint.style.opacity = '0.6';
                }
            }
        }
        
        function updateNavButtons() {
            const navButtons = document.querySelectorAll('.nav-btn');
            if (navButtons.length >= 3) {
                const backBtn = navButtons[0];
                const forwardBtn = navButtons[1];
                const restartBtn = navButtons[2];
                
                backBtn.style.display = currentSlide === 1 ? 'none' : 'flex';
                forwardBtn.style.display = currentSlide === totalSlides ? 'none' : 'flex';
                
                // Show restart button on last slide with animation
                if (currentSlide === totalSlides) {
                    restartBtn.style.display = 'flex';
                    setTimeout(() => {
                        restartBtn.style.opacity = '1';
                    }, 100);
                } else {
                    restartBtn.style.opacity = '0';
                    setTimeout(() => {
                        restartBtn.style.display = 'none';
                    }, 300);
                }
            }
        }

        function initializeSlide(slideNum) {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Small delay to ensure DOM is ready
            setTimeout(() => {
                switch(slideNum) {
                    case 1:
                        // First slide - no special initialization needed
                        break;
                    case 2:
                        initTriangleVisualization();
                        break;
                    case 3:
                        initEigenVisualization();
                        break;
                    case 4:
                        initLODVisualization();
                        break;
                    case 5:
                        initCellVisualization();
                        break;
                    case 6:
                        // Last slide - no special initialization needed
                        break;
                }
            }, 50);
        }

        function initTriangleVisualization() {
            compressionView = false; // Reset to default view
            const canvas = document.getElementById('triangleCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            generateTriangles();
            drawTriangles(ctx);
        }

        function generateTriangles() {
            triangles = [];
            const count = 1000;
            const size = 8;
            const canvas = document.getElementById('triangleCanvas');
            const canvasWidth = canvas ? canvas.offsetWidth : 800;
            const canvasHeight = canvas ? canvas.offsetHeight : 400;
            
            for (let i = 0; i < count; i++) {
                triangles.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    size: size + (Math.random() - 0.5) * 2,
                    rotation: Math.random() * Math.PI * 2,
                    color: `hsl(${260 + Math.random() * 40}, 70%, ${50 + Math.random() * 20}%)`
                });
            }
        }

        function drawTriangles(ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (compressionView) {
                // Generate triangles from compressed parameters
                const compressedParams = {
                    triangleSize: 8,
                    count: 1000,
                    distribution: 'uniform_random',
                    spacing: 25,
                    colorHue: { min: 260, max: 300 },
                    rotation: { min: 0, max: 2 * Math.PI },
                    seed: 42 // For reproducibility
                };
                
                // Use a seeded random for reproducible patterns
                let seed = compressedParams.seed;
                function seededRandom() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                }
                
                // Generate and draw triangles from compressed representation
                for (let i = 0; i < compressedParams.count; i++) {
                    const x = seededRandom() * ctx.canvas.width;
                    const y = seededRandom() * ctx.canvas.height;
                    const size = compressedParams.triangleSize + (seededRandom() - 0.5) * 2;
                    const rotation = compressedParams.rotation.min + seededRandom() * (compressedParams.rotation.max - compressedParams.rotation.min);
                    const hue = compressedParams.colorHue.min + seededRandom() * (compressedParams.colorHue.max - compressedParams.colorHue.min);
                    const color = `hsl(${hue}, 70%, ${50 + seededRandom() * 20}%)`;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.7;
                    drawTriangle(ctx, 0, 0, size, 0);
                    ctx.restore();
                }
                
                // Overlay the parameter display
                ctx.fillStyle = 'rgba(15, 15, 35, 0.9)';
                ctx.fillRect(10, 10, 280, 180);
                
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 18px monospace';
                ctx.fillText('Generated from:', 20, 35);
                ctx.font = '14px monospace';
                ctx.fillStyle = '#a78bfa';
                ctx.fillText(`triangleSize: ${compressedParams.triangleSize}`, 20, 60);
                ctx.fillText(`count: ${compressedParams.count}`, 20, 80);
                ctx.fillText(`distribution: ${compressedParams.distribution}`, 20, 100);
                ctx.fillText(`spacing: ~${compressedParams.spacing}px`, 20, 120);
                ctx.fillText(`colorHue: ${compressedParams.colorHue.min}-${compressedParams.colorHue.max}`, 20, 140);
                ctx.fillText(`rotation: 0-2π`, 20, 160);
                ctx.fillText(`seed: ${compressedParams.seed}`, 20, 180);
                
                // Add a subtle border effect
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, 280, 180);
            } else {
                // Draw all triangles from raw storage
                triangles.forEach(t => {
                    ctx.save();
                    ctx.translate(t.x, t.y);
                    ctx.rotate(t.rotation);
                    ctx.fillStyle = t.color;
                    ctx.globalAlpha = 0.7;
                    drawTriangle(ctx, 0, 0, t.size, 0);
                    ctx.restore();
                });
                
                // Show storage info
                ctx.fillStyle = 'rgba(15, 15, 35, 0.9)';
                ctx.fillRect(10, 10, 200, 60);
                ctx.fillStyle = '#f093fb';
                ctx.font = 'bold 18px monospace';
                ctx.fillText('Raw Storage:', 20, 35);
                ctx.font = '14px monospace';
                ctx.fillStyle = '#a78bfa';
                ctx.fillText('6000 coordinates', 20, 55);
            }
        }

        function drawTriangle(ctx, x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(-size * 0.866, size * 0.5);
            ctx.lineTo(size * 0.866, size * 0.5);
            ctx.closePath();
            if (ctx.fillStyle) ctx.fill();
            if (ctx.strokeStyle) ctx.stroke();
            ctx.restore();
        }

        function regenerateTriangles() {
            compressionView = false; // Always show raw view when regenerating
            generateTriangles();
            const canvas = document.getElementById('triangleCanvas');
            const ctx = canvas.getContext('2d');
            
            // Add a brief flash effect
            canvas.style.opacity = '0.3';
            setTimeout(() => {
                drawTriangles(ctx);
                canvas.style.opacity = '1';
            }, 150);
        }

        function toggleCompression() {
            compressionView = !compressionView;
            const canvas = document.getElementById('triangleCanvas');
            const ctx = canvas.getContext('2d');
            
            // Add a brief transition effect
            canvas.style.opacity = '0.3';
            setTimeout(() => {
                drawTriangles(ctx);
                canvas.style.opacity = '1';
            }, 150);
        }

        function initEigenVisualization() {
            const canvas = document.getElementById('eigenCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            drawEigenSpace(ctx);
        }

        function drawEigenSpace(ctx) {
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            
            // Draw coordinate system
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(ctx.canvas.width - 50, centerY);
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, ctx.canvas.height - 50);
            ctx.stroke();
            
            // Draw eigenvectors
            ctx.strokeStyle = '#f093fb';
            ctx.lineWidth = 3;
            
            // First eigenvector
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + 150, centerY - 100);
            ctx.stroke();
            
            // Second eigenvector
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + 100, centerY + 120);
            ctx.stroke();
            
            // Draw data points
            for (let i = 0; i < 100; i++) {
                const angle = (i / 100) * Math.PI * 2;
                const radius = 50 + Math.random() * 100;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius * 0.6;
                
                ctx.fillStyle = `hsl(${260 + i * 1.4}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function animateEigenDecomposition() {
            const canvas = document.getElementById('eigenCanvas');
            const ctx = canvas.getContext('2d');
            let progress = 0;
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawEigenSpace(ctx);
                
                progress += 0.02;
                if (progress < 1) {
                    ctx.globalAlpha = progress;
                    ctx.fillStyle = '#a78bfa';
                    ctx.font = '16px monospace';
                    ctx.fillText('Decomposing into orthogonal components...', 50, 30);
                    animationFrame = requestAnimationFrame(animate);
                }
            }
            animate();
        }

        function reconstructFromEigen() {
            const values = [
                { id: 'colorValue', text: 'RGB(180, 120, 240)' },
                { id: 'sizeValue', text: '22.7 units' },
                { id: 'frequencyValue', text: '0.91' },
                { id: 'spatialValue', text: 'Gaussian(μ=0.3, σ=0.15)' }
            ];
            
            values.forEach((v, i) => {
                setTimeout(() => {
                    const el = document.getElementById(v.id);
                    if (el) {
                        el.textContent = v.text;
                        el.style.color = '#a78bfa';
                    }
                }, i * 200);
            });
        }

        function initLODVisualization() {
            const canvas = document.getElementById('lodCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            drawLODSystem(ctx, 5);
        }

        function drawLODSystem(ctx, level) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            
            // Draw a golden poppy with varying detail levels
            if (level <= 2) {
                // Very low detail - basic flower shape
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 60, 0, Math.PI * 2);
                ctx.fill();
                
                // Stem
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.lineTo(centerX, centerY + 150);
                ctx.stroke();
                
            } else if (level <= 4) {
                // Low detail - distinct petals
                ctx.fillStyle = '#fbbf24';
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const petalX = centerX + Math.cos(angle) * 30;
                    const petalY = centerY - 20 + Math.sin(angle) * 30;
                    ctx.beginPath();
                    ctx.ellipse(petalX, petalY, 35, 25, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Center
                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Stem with basic curve
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.quadraticCurveTo(centerX - 10, centerY + 80, centerX - 5, centerY + 150);
                ctx.stroke();
                
            } else if (level <= 6) {
                // Medium detail - realistic petal shapes
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    const petalX = centerX + Math.cos(angle) * 35;
                    const petalY = centerY - 20 + Math.sin(angle) * 35;
                    
                    // Petal with gradient
                    const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 35);
                    gradient.addColorStop(0, '#fde68a');
                    gradient.addColorStop(0.7, '#fbbf24');
                    gradient.addColorStop(1, '#f59e0b');
                    ctx.fillStyle = gradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - 20);
                    ctx.quadraticCurveTo(
                        petalX + Math.cos(angle - 0.5) * 20, 
                        petalY + Math.sin(angle - 0.5) * 20,
                        petalX + Math.cos(angle) * 40, 
                        petalY + Math.sin(angle) * 40
                    );
                    ctx.quadraticCurveTo(
                        petalX + Math.cos(angle + 0.5) * 20, 
                        petalY + Math.sin(angle + 0.5) * 20,
                        centerX, centerY - 20
                    );
                    ctx.fill();
                }
                
                // Detailed center with texture
                ctx.fillStyle = '#ea580c';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 18, 0, Math.PI * 2);
                ctx.fill();
                
                // Add some texture dots
                for (let i = 0; i < 10; i++) {
                    const r = Math.random() * 12;
                    const a = Math.random() * Math.PI * 2;
                    ctx.fillStyle = '#7c2d12';
                    ctx.beginPath();
                    ctx.arc(centerX + Math.cos(a) * r, centerY - 20 + Math.sin(a) * r, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Stem with thorns
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.quadraticCurveTo(centerX - 15, centerY + 80, centerX - 5, centerY + 150);
                ctx.stroke();
                
                // Leaves
                ctx.fillStyle = '#16a34a';
                ctx.beginPath();
                ctx.ellipse(centerX - 20, centerY + 80, 15, 8, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (level <= 8) {
                // High detail - complex petal structure
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    const petalX = centerX + Math.cos(angle) * 35;
                    const petalY = centerY - 20 + Math.sin(angle) * 35;
                    
                    // Multi-layer gradient for silk-like appearance
                    const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 40);
                    gradient.addColorStop(0, '#fef3c7');
                    gradient.addColorStop(0.3, '#fde68a');
                    gradient.addColorStop(0.6, '#fbbf24');
                    gradient.addColorStop(0.9, '#f59e0b');
                    gradient.addColorStop(1, '#dc2626');
                    ctx.fillStyle = gradient;
                    
                    // Ruffled petal edges
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - 20);
                    for (let j = 0; j <= 20; j++) {
                        const t = j / 20;
                        const baseAngle = angle - 0.6 + t * 1.2;
                        const radius = 35 + Math.sin(j * 2) * 3;
                        const px = centerX + Math.cos(baseAngle) * radius;
                        const py = centerY - 20 + Math.sin(baseAngle) * radius;
                        if (j === 0) {
                            ctx.lineTo(px, py);
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Petal veins
                    ctx.strokeStyle = 'rgba(245, 158, 11, 0.3)';
                    ctx.lineWidth = 0.5;
                    for (let v = 0; v < 3; v++) {
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        const vAngle = angle + (v - 1) * 0.2;
                        ctx.quadraticCurveTo(
                            centerX + Math.cos(vAngle) * 20,
                            centerY - 20 + Math.sin(vAngle) * 20,
                            centerX + Math.cos(vAngle) * 40,
                            centerY - 20 + Math.sin(vAngle) * 40
                        );
                        ctx.stroke();
                    }
                }
                
                // Highly detailed center
                const centerGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 20);
                centerGradient.addColorStop(0, '#7c2d12');
                centerGradient.addColorStop(0.5, '#dc2626');
                centerGradient.addColorStop(1, '#ea580c');
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Pollen texture
                for (let i = 0; i < 30; i++) {
                    const r = Math.random() * 15;
                    const a = Math.random() * Math.PI * 2;
                    ctx.fillStyle = `rgba(124, 45, 18, ${Math.random() * 0.5 + 0.5})`;
                    ctx.beginPath();
                    ctx.arc(centerX + Math.cos(a) * r, centerY - 20 + Math.sin(a) * r, Math.random() * 2 + 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Detailed stem with natural curve
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.bezierCurveTo(
                    centerX - 10, centerY + 70,
                    centerX - 20, centerY + 100,
                    centerX - 8, centerY + 150
                );
                ctx.stroke();
                
                // Multiple leaves with veins
                const leaves = [
                    { x: centerX - 25, y: centerY + 75, angle: -0.4 },
                    { x: centerX - 15, y: centerY + 110, angle: -0.2 }
                ];
                
                leaves.forEach(leaf => {
                    ctx.fillStyle = '#16a34a';
                    ctx.save();
                    ctx.translate(leaf.x, leaf.y);
                    ctx.rotate(leaf.angle);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 18, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Leaf veins
                    ctx.strokeStyle = '#14532d';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.lineTo(15, 0);
                    ctx.stroke();
                    ctx.restore();
                });
                
            } else {
                // Ultra high detail - botanical illustration quality
                // Draw with maximum botanical accuracy
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    
                    // Each petal with unique characteristics
                    for (let layer = 0; layer < 3; layer++) {
                        const layerOffset = layer * 2;
                        const petalX = centerX + Math.cos(angle) * (35 - layerOffset);
                        const petalY = centerY - 20 + Math.sin(angle) * (35 - layerOffset);
                        
                        const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 45 - layerOffset);
                        gradient.addColorStop(0, `rgba(254, 243, 199, ${1 - layer * 0.2})`);
                        gradient.addColorStop(0.3, `rgba(253, 230, 138, ${1 - layer * 0.2})`);
                        gradient.addColorStop(0.5, `rgba(251, 191, 36, ${1 - layer * 0.2})`);
                        gradient.addColorStop(0.8, `rgba(245, 158, 11, ${1 - layer * 0.2})`);
                        gradient.addColorStop(1, `rgba(220, 38, 38, ${0.8 - layer * 0.2})`);
                        ctx.fillStyle = gradient;
                        
                        // Irregular petal shape
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        for (let j = 0; j <= 30; j++) {
                            const t = j / 30;
                            const baseAngle = angle - 0.7 + t * 1.4;
                            const irregularity = Math.sin(j * 3) * 2 + Math.sin(j * 7) * 1;
                            const radius = (38 - layerOffset) + irregularity + Math.random() * 1;
                            const px = centerX + Math.cos(baseAngle) * radius;
                            const py = centerY - 20 + Math.sin(baseAngle) * radius;
                            ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Fine petal veins
                    ctx.strokeStyle = 'rgba(220, 38, 38, 0.15)';
                    ctx.lineWidth = 0.3;
                    for (let v = 0; v < 7; v++) {
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        const vAngle = angle + (v - 3) * 0.15;
                        const controlX = centerX + Math.cos(vAngle) * 20;
                        const controlY = centerY - 20 + Math.sin(vAngle) * 20;
                        const endX = centerX + Math.cos(vAngle) * (38 + Math.random() * 5);
                        const endY = centerY - 20 + Math.sin(vAngle) * (38 + Math.random() * 5);
                        ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                        ctx.stroke();
                    }
                }
                
                // Ultra-detailed center with stamens
                const centerGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 22);
                centerGradient.addColorStop(0, '#451a03');
                centerGradient.addColorStop(0.3, '#7c2d12');
                centerGradient.addColorStop(0.6, '#dc2626');
                centerGradient.addColorStop(1, '#f97316');
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 22, 0, Math.PI * 2);
                ctx.fill();
                
                // Individual pollen grains and stamens
                for (let ring = 0; ring < 3; ring++) {
                    const count = 10 + ring * 8;
                    for (let i = 0; i < count; i++) {
                        const a = (i / count) * Math.PI * 2;
                        const r = 8 + ring * 5;
                        const x = centerX + Math.cos(a) * r;
                        const y = centerY - 20 + Math.sin(a) * r;
                        
                        // Stamen
                        ctx.strokeStyle = '#7c2d12';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        
                        // Pollen
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(x, y, 1 + Math.random() * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Photorealistic stem with natural imperfections
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.bezierCurveTo(
                    centerX - 12, centerY + 70,
                    centerX - 22, centerY + 100,
                    centerX - 10, centerY + 150
                );
                ctx.stroke();
                
                // Stem texture
                ctx.strokeStyle = '#14532d';
                ctx.lineWidth = 0.3;
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    const sy = centerY + 50 + i * 5;
                    const sx = centerX - 10 + Math.sin(sy * 0.1) * 10;
                    ctx.moveTo(sx - 2, sy);
                    ctx.lineTo(sx + 2, sy);
                    ctx.stroke();
                }
                
                // Detailed compound leaves with serrated edges
                const leaves = [
                    { x: centerX - 28, y: centerY + 70, angle: -0.4, size: 1 },
                    { x: centerX - 18, y: centerY + 105, angle: -0.2, size: 0.8 },
                    { x: centerX - 5, y: centerY + 125, angle: 0.1, size: 0.6 }
                ];
                
                leaves.forEach(leaf => {
                    ctx.save();
                    ctx.translate(leaf.x, leaf.y);
                    ctx.rotate(leaf.angle);
                    ctx.scale(leaf.size, leaf.size);
                    
                    // Leaf with serrated edges
                    ctx.fillStyle = '#16a34a';
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    for (let i = 0; i <= 20; i++) {
                        const x = -20 + i * 2;
                        const y = Math.sin(i * 0.8) * 3 * Math.sin(x * 0.1 + 1.5);
                        ctx.lineTo(x, y + (i % 2 ? -2 : 2));
                    }
                    for (let i = 20; i >= 0; i--) {
                        const x = -20 + i * 2;
                        const y = Math.sin(i * 0.8) * 3 * Math.sin(x * 0.1 + 1.5);
                        ctx.lineTo(x, -y + (i % 2 ? 2 : -2));
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Leaf veins
                    ctx.strokeStyle = '#0f4a2a';
                    ctx.lineWidth = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(20, 0);
                    ctx.stroke();
                    
                    for (let v = -15; v <= 15; v += 5) {
                        ctx.beginPath();
                        ctx.moveTo(v, 0);
                        ctx.lineTo(v + 3, 4);
                        ctx.moveTo(v, 0);
                        ctx.lineTo(v + 3, -4);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
            }
        }

        function updateLOD(value) {
            const level = parseInt(value);
            document.getElementById('lodValue').textContent = level;
            
            const canvas = document.getElementById('lodCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                drawLODSystem(ctx, level);
            }
            
            // Update info based on golden poppy detail level
            let title, description, params;
            if (level <= 2) {
                title = 'Minimal Detail';
                description = 'Basic flower shape and color. Sufficient for general categorization.';
                params = 10;
            } else if (level <= 4) {
                title = 'Low Detail';
                description = 'Distinct petals and center visible. Good for species identification.';
                params = 50;
            } else if (level <= 6) {
                title = 'Medium Detail';
                description = 'Petal gradients, basic texture, leaves. Suitable for botanical classification.';
                params = 500;
            } else if (level <= 8) {
                title = 'High Detail';
                description = 'Complex petal structure, veins, detailed stem. For growth analysis or health assessment.';
                params = 5000;
            } else {
                title = 'Maximum Detail';
                description = 'Botanical illustration quality. Individual pollen grains, cell-level features. For scientific study.';
                params = 50000;
            }
            
            const titleEl = document.getElementById('lodTitle');
            const descEl = document.getElementById('lodDescription');
            const paramEl = document.getElementById('paramCount');
            const ratioEl = document.getElementById('compressionRatio');
            
            if (titleEl) titleEl.textContent = title;
            if (descEl) descEl.textContent = description;
            if (paramEl) paramEl.textContent = params.toLocaleString();
            if (ratioEl) ratioEl.textContent = `${Math.floor(1000000/params)}:1`;
        }

        function simulateProblem(complexity) {
            const slider = document.getElementById('lodSlider');
            if (!slider) return;
            const targetValue = complexity === 'simple' ? 2 : 9;
            
            let current = parseInt(slider.value);
            const step = current < targetValue ? 1 : -1;
            
            function adjustDetail() {
                if (current !== targetValue) {
                    current += step;
                    slider.value = current;
                    updateLOD(current);
                    setTimeout(adjustDetail, 200);
                }
            }
            adjustDetail();
        }

        function autoAdapt() {
            const sequence = [2, 4, 6, 8, 10, 8, 5, 3, 7, 9, 4];
            let index = 0;
            
            function nextAdaptation() {
                if (index < sequence.length) {
                    const slider = document.getElementById('lodSlider');
                    if (slider) {
                        slider.value = sequence[index];
                        updateLOD(sequence[index]);
                    }
                    index++;
                    setTimeout(nextAdaptation, 800);
                }
            }
            nextAdaptation();
        }

        function initCellVisualization() {
            const canvas = document.getElementById('cellCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            drawCell(ctx, 'cell');
        }

        function drawCell(ctx, zoomLevel) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            
            if (zoomLevel === 'molecular') {
                // Draw molecular level - proteins, DNA strands, etc.
                // DNA double helix
                for (let i = 0; i < 100; i++) {
                    const t = i / 100;
                    const x1 = centerX - 100 + t * 200;
                    const y1 = centerY + Math.sin(t * Math.PI * 4) * 50;
                    const y2 = centerY + Math.sin(t * Math.PI * 4 + Math.PI) * 50;
                    
                    // Base pairs
                    ctx.strokeStyle = `hsla(${200 + i * 1.5}, 70%, 60%, 0.8)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1, y2);
                    ctx.stroke();
                    
                    // Sugar-phosphate backbone
                    ctx.fillStyle = '#667eea';
                    ctx.beginPath();
                    ctx.arc(x1, y1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#f093fb';
                    ctx.beginPath();
                    ctx.arc(x1, y2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Proteins
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    
                    // Alpha helices
                    ctx.strokeStyle = `hsla(${Math.random() * 60 + 30}, 70%, 60%, 0.6)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let j = 0; j < 10; j++) {
                        const angle = j * 0.6;
                        const px = x + Math.cos(angle) * 10;
                        const py = y + j * 3 + Math.sin(angle) * 5;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // ATP molecules
                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    ctx.fillStyle = '#667eea';
                    
                    // Adenosine
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Phosphate groups
                    for (let p = 0; p < 3; p++) {
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(x + (p + 1) * 10, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x + p * 10, y);
                        ctx.lineTo(x + (p + 1) * 10, y);
                        ctx.stroke();
                    }
                }
                
                // Water molecules
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    ctx.fillStyle = 'rgba(147, 197, 253, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
            } else if (zoomLevel === 'organelle') {
                // Draw detailed organelles
                
                // Cell membrane (more detailed)
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 170, 140, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Nucleus with nucleolus
                const nucleusGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 50);
                nucleusGradient.addColorStop(0, 'rgba(102, 126, 234, 0.8)');
                nucleusGradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.5)');
                nucleusGradient.addColorStop(1, 'rgba(102, 126, 234, 0.2)');
                ctx.fillStyle = nucleusGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 50, 0, Math.PI * 2);
                ctx.fill();
                
                // Nuclear pores
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * 45;
                    const y = centerY - 20 + Math.sin(angle) * 45;
                    ctx.fillStyle = '#4c1d95';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Nucleolus
                ctx.fillStyle = 'rgba(76, 29, 149, 0.7)';
                ctx.beginPath();
                ctx.arc(centerX + 10, centerY - 25, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Mitochondria (with cristae)
                const mitochondria = [
                    { x: centerX - 80, y: centerY + 30, w: 40, h: 20, angle: 0.3 },
                    { x: centerX + 70, y: centerY - 60, w: 35, h: 18, angle: -0.4 },
                    { x: centerX + 90, y: centerY + 50, w: 38, h: 19, angle: 0.2 }
                ];
                
                mitochondria.forEach(mito => {
                    ctx.save();
                    ctx.translate(mito.x, mito.y);
                    ctx.rotate(mito.angle);
                    
                    // Outer membrane
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, mito.w, mito.h, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cristae (internal folds)
                    ctx.strokeStyle = '#7c3aed';
                    ctx.lineWidth = 1.5;
                    for (let i = -mito.w + 10; i < mito.w - 10; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(i, -mito.h * 0.6);
                        ctx.quadraticCurveTo(i + 4, 0, i, mito.h * 0.6);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
                
                // Endoplasmic reticulum (rough with ribosomes)
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - 120, centerY - 80);
                ctx.bezierCurveTo(
                    centerX - 80, centerY - 60,
                    centerX - 40, centerY - 90,
                    centerX, centerY - 70
                );
                ctx.bezierCurveTo(
                    centerX + 40, centerY - 50,
                    centerX + 80, centerY - 80,
                    centerX + 120, centerY - 60
                );
                ctx.stroke();
                
                // Ribosomes on ER
                for (let i = 0; i < 15; i++) {
                    const t = i / 15;
                    const x = centerX - 120 + t * 240;
                    const y = centerY - 75 + Math.sin(t * Math.PI * 2) * 15;
                    ctx.fillStyle = '#7c2d12';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Golgi apparatus (stacked cisternae)
                ctx.save();
                ctx.translate(centerX - 60, centerY + 70);
                for (let i = 0; i < 5; i++) {
                    ctx.strokeStyle = `rgba(249, 115, 22, ${0.8 - i * 0.1})`;
                    ctx.lineWidth = 3 - i * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, i * 6);
                    ctx.bezierCurveTo(
                        20, i * 6 - 5,
                        40, i * 6 + 5,
                        60, i * 6
                    );
                    ctx.stroke();
                }
                ctx.restore();
                
                // Lysosomes
                for (let i = 0; i < 4; i++) {
                    const x = centerX + Math.random() * 100 - 50;
                    const y = centerY + Math.random() * 100 - 50;
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Digestive enzymes
                    for (let j = 0; j < 3; j++) {
                        ctx.fillStyle = '#7f1d1d';
                        ctx.beginPath();
                        ctx.arc(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Cytoskeleton filaments
                ctx.strokeStyle = 'rgba(147, 51, 234, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    const startX = Math.random() * ctx.canvas.width;
                    const startY = Math.random() * ctx.canvas.height;
                    const endX = startX + Math.random() * 100 - 50;
                    const endY = startY + Math.random() * 100 - 50;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
            } else {
                // Full cell view with all components visible
                
                // Cell membrane with lipid bilayer detail
                ctx.strokeStyle = '#4c1d95';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 150, 120, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner membrane layer
                ctx.strokeStyle = '#6d28d9';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 145, 115, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Nucleus
                ctx.fillStyle = 'rgba(102, 126, 234, 0.4)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 45, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Nucleolus
                ctx.fillStyle = 'rgba(76, 29, 149, 0.6)';
                ctx.beginPath();
                ctx.arc(centerX + 10, centerY - 5, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Mitochondria
                const mitoPositions = [
                    { x: -70, y: 30, r: 15 },
                    { x: 60, y: -40, r: 12 },
                    { x: 80, y: 40, r: 13 },
                    { x: -50, y: -50, r: 11 }
                ];
                
                mitoPositions.forEach(pos => {
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(centerX + pos.x, centerY + pos.y, pos.r * 1.5, pos.r, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // ER network
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - 100, centerY - 60);
                ctx.quadraticCurveTo(centerX - 50, centerY - 40, centerX, centerY - 50);
                ctx.quadraticCurveTo(centerX + 50, centerY - 60, centerX + 100, centerY - 40);
                ctx.stroke();
                
                // Golgi
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.6)';
                ctx.lineWidth = 3;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(centerX - 80, centerY + 50 + i * 5);
                    ctx.lineTo(centerX - 40, centerY + 50 + i * 5);
                    ctx.stroke();
                }
                
                // Lysosomes and vesicles
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 60 + Math.random() * 40;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.fillStyle = i < 4 ? 'rgba(239, 68, 68, 0.5)' : 'rgba(147, 51, 234, 0.4)';
                    ctx.beginPath();
                    ctx.arc(x, y, 5 + Math.random() * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Cytoplasm dots
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 140;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    // Check if inside cell
                    const ellipseCheck = Math.pow((x - centerX) / 150, 2) + Math.pow((y - centerY) / 120, 2);
                    if (ellipseCheck < 1) {
                        ctx.fillStyle = 'rgba(147, 197, 253, 0.2)';
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function zoomToMolecular() {
            const ctx = document.getElementById('cellCanvas').getContext('2d');
            drawCell(ctx, 'molecular');
        }

        function zoomToOrganelle() {
            const ctx = document.getElementById('cellCanvas').getContext('2d');
            drawCell(ctx, 'organelle');
        }

        function zoomToCell() {
            const ctx = document.getElementById('cellCanvas').getContext('2d');
            drawCell(ctx, 'cell');
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // If on first slide and navigation not yet visible, show it immediately on any arrow key
            if (currentSlide === 1 && navigationTimeout && (e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
                clearTimeout(navigationTimeout);
                navigationTimeout = null;
                showNavigation();
            }
            
            if (e.key === 'ArrowRight' && currentSlide < totalSlides) {
                nextSlide();
            }
            if (e.key === 'ArrowLeft' && currentSlide > 1) {
                previousSlide();
            }
        });
        
        // Initialize navigation buttons once DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updateNavButtons();
                // Fade in navigation on first slide after delay
                if (currentSlide === 1) {
                    navigationTimeout = setTimeout(() => {
                        showNavigation();
                        navigationTimeout = null;
                    }, 3000); // 3 second delay
                }
            });
        } else {
            // Delay slightly to ensure DOM is fully constructed
            setTimeout(() => {
                updateNavButtons();
                // Fade in navigation on first slide after delay
                if (currentSlide === 1) {
                    navigationTimeout = setTimeout(() => {
                        showNavigation();
                        navigationTimeout = null;
                    }, 3000); // 3 second delay
                }
            }, 0);
        }
    </script>
</body>
</html>

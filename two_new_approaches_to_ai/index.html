<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>The Next Algorithms: Knowledge Compression & Adaptive Complexity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Prevent text selection in navigation elements */
        .navigation, button {
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            color: #e0e0ff;
            overflow-x: hidden;
            overflow-y: auto;
            line-height: 1.5;
            font-size: 0.9rem;
            margin: 0;
            padding: 0;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        .presentation {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            touch-action: pan-y;
        }

        .slide {
            min-height: 100vh;
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 2rem 1.2rem 5rem;
            position: relative;
            opacity: 0;
            animation: fadeIn 1s forwards;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Center content on larger screens */
        @media (min-width: 769px) {
            .slide {
                height: 100vh;
                justify-content: center;
                padding: 0.8rem 1.2rem;
            }
        }

        .slide.active {
            display: flex;
        }

        /* Ensure content doesn't overflow horizontally on mobile */
        @media (max-width: 768px) {
            .slide {
                width: 100vw;
                max-width: 100vw;
                overflow-x: hidden;
                padding-top: 1rem;
            }

            .slide-content {
                max-width: 100%;
                padding: 0 0.5rem;
                margin-top: 0;
            }

            /* Special handling for title slide on mobile */
            #slide1 {
                justify-content: flex-start;
                padding-top: 3rem;
            }
        }
        
        /* Base grid layout for all slide content */
        .slide-content {
            width: 100%;
            max-width: 1300px;
            display: grid;
            gap: 1.2rem;
            align-items: start;
            margin: 0 auto;
        }
        
        /* Slide title above both columns */
        .slide-title {
            grid-column: 1 / -1;
            font-size: clamp(1.3rem, 2vw, 1.8rem);
            color: #a78bfa;
            margin-bottom: 1rem;
            text-align: center;
        }

        /* Two-column layout explicitly for slides 2-6 */
        #slide2 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }

        #slide3 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }

        #slide4 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }

        #slide5 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }

        #slide6 .slide-content {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
        }
        
        /* Single column only for title slide */
        #slide1 .slide-content,
        .slide-content.single-column {
            grid-template-columns: 1fr !important;
            max-width: 1200px;
        }
        
        /* Debug: Ensure left and right panels are visible as columns */
        .slide:not(#slide1) .left-panel,
        .slide:not(#slide1) .right-panel {
            min-width: 0;
            width: 100%;
        }
        
        /* Visual separator for two-column layout */
        .slide:not(#slide1) .left-panel {
            padding-right: 1.5rem;
            position: relative;
            border-right: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .slide:not(#slide1) .right-panel {
            padding-left: 1.5rem;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        h1 {
            font-size: clamp(1.8rem, 3.5vw, 3rem);
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 1.2rem;
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        h2 {
            font-size: clamp(1.1rem, 1.8vw, 1.6rem);
            color: #a78bfa;
            margin-bottom: 0.6rem;
            text-align: left;
        }

        .visualization {
            width: 100%;
            height: 320px;
            margin: 0.6rem 0;
            background: rgba(30, 30, 50, 0.8);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-sizing: border-box;
            touch-action: none;
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
            transition: opacity 0.3s ease;
            touch-action: none;
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        button {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .info-box {
            background: rgba(30, 30, 50, 0.6);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1rem auto;
            max-width: 700px;
            backdrop-filter: blur(10px);
        }

        .parameter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            padding: 0.5rem;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .parameter label {
            font-weight: 500;
            color: #a78bfa;
        }

        .parameter span {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .compression-comparison {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.6rem;
            margin: 0.6rem 0;
            width: 100%;
        }

        .comparison-box {
            padding: 0.7rem;
            background: rgba(30, 30, 50, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            font-size: 0.85rem;
            width: 100%;
            box-sizing: border-box;
        }

        .comparison-box h3 {
            color: #f093fb;
            margin-bottom: 0.4rem;
            font-size: 0.95rem;
        }
        
        .comparison-box ul {
            margin: 0;
            padding-left: 1.2rem;
        }
        
        .comparison-box p {
            margin: 0.2rem 0;
        }

        .stats {
            font-family: 'Courier New', monospace;
            color: #a78bfa;
            font-size: 1.2rem;
            margin: 0.5rem 0;
        }

        .slider-container {
            margin: 0.8rem 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 0.5rem;
            color: #a78bfa;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: rgba(102, 126, 234, 0.3);
            outline: none;
            touch-action: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            cursor: pointer;
        }

        .navigation {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            gap: 0.8rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 1s ease;
            pointer-events: none;
        }
        
        .navigation.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .navigation.visible .nav-btn {
            animation: gentlePulse 2s ease-in-out 1;
        }
        
        @keyframes gentlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .nav-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }

        /* Make navigation buttons translucent on mobile */
        @media (max-width: 768px) {
            .nav-btn {
                background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            }

            .nav-btn:hover, .nav-btn:active {
                background: linear-gradient(135deg, rgba(102, 126, 234, 0.5) 0%, rgba(118, 75, 162, 0.5) 100%);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
        }

        .quote {
            font-style: italic;
            color: #a78bfa;
            margin: 1.5rem auto;
            max-width: 600px;
            padding: 1rem;
            border-left: 4px solid #667eea;
            background: rgba(30, 30, 50, 0.4);
        }

        .highlight {
            color: #a78bfa;
            font-weight: bold;
        }
        
        ul {
            font-size: 0.85rem;
        }
        
        li {
            margin: 0.15rem 0;
        }
        
        p {
            margin: 0.4rem 0;
            line-height: 1.4;
            word-wrap: break-word;
        }
        
        /* Ensure two-column layout for content slides */
        #slide2 .slide-content,
        #slide3 .slide-content,
        #slide4 .slide-content,
        #slide5 .slide-content,
        #slide6 .slide-content {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
        }
        
        @media (max-width: 1200px) {
            .slide-content {
                gap: 0.8rem;
            }
            
            .visualization {
                height: 280px;
            }
        }
        
        @media (max-width: 1024px) {
            .slide:not(#slide1) .slide-content {
                grid-template-columns: 1fr !important;
                gap: 1.5rem;
            }
            
            .slide:not(#slide1) .left-panel {
                padding-right: 0;
                border-right: none;
            }
            
            .slide:not(#slide1) .right-panel {
                padding-left: 0;
            }
            
            .visualization {
                height: 300px;
            }
        }
        
        @media (max-width: 768px) {
            .navigation {
                bottom: 1rem;
                right: 1rem;
            }

            .nav-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .slide {
                padding: 0.6rem 1rem;
            }

            .visualization {
                height: 250px;
            }
        }

    </style>
</head>
<body>
    <div class="presentation">
        <!-- Slide 1: Title -->
        <div class="slide active" id="slide1">
            <div class="slide-content single-column">
                <div style="text-align: center;">
                    <h1>The Next Algorithms</h1>
                    <h2 style="text-align: center;">Knowledge Compression & Adaptive Complexity</h2>
                    <div class="quote">
                        "AGI is just a few more algorithms away..."
                    </div>
                    <p style="margin-top: 2rem; font-size: 1.2rem;">
                        Two fundamental ideas that could transform how AI understands and interacts with the world
                    </p>
                    <p id="navHint" style="margin-top: 3rem; font-size: 0.9rem; color: #a78bfa; opacity: 0; transition: opacity 1.5s ease;">
                        Navigate with arrow keys or → button
                    </p>
                </div>
            </div>
        </div>

        <!-- Slide 2: Knowledge Compression Introduction -->
        <div class="slide" id="slide2">
            <div class="slide-content">
                <h2 class="slide-title">Idea 1: Knowledge Compression</h2>
                <div class="left-panel">
                    <div class="info-box">
                        <p>Complex patterns can be represented with minimal information when we understand their underlying structure.</p>
                        <p style="margin-top: 1rem;">Example: <span class="highlight">1000 equilateral triangles</span> on a screen.</p>
                        <p style="margin-top: 0.5rem; color: #a78bfa;">
                            The same visual information can be stored as either 6000 coordinates or ~10 parameters that describe the pattern.
                        </p>
                    </div>

                    <div class="compression-comparison" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.8rem;">
                        <div class="comparison-box">
                            <h3>Traditional Storage</h3>
                            <p>Store every vertex position</p>
                            <div class="stats">6000 numbers</div>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">
                                (1000 triangles × 3 vertices × 2 coordinates)
                            </p>
                            <p style="color: #a78bfa; margin-top: 0.8rem; font-size: 0.85rem;">
                                • Large storage requirement<br>
                                • No pattern understanding
                            </p>
                        </div>
                        <div class="comparison-box">
                            <h3>Compressed Representation</h3>
                            <p>Store pattern parameters</p>
                            <div class="stats">~10 numbers</div>
                            <ul style="text-align: left; margin-top: 0.5rem; font-size: 0.85rem; padding-left: 1rem;">
                                <li>Triangle size</li>
                                <li>Count</li>
                                <li>Distribution randomness</li>
                                <li>Average spacing</li>
                                <li>Color parameters</li>
                            </ul>
                            <p style="color: #a78bfa; margin-top: 0.8rem; font-size: 0.85rem;">
                                • Same visual result<br>
                                • 600:1 compression ratio
                            </p>
                        </div>
                    </div>
                </div>

                <div class="right-panel">
                    <div class="visualization">
                        <canvas id="triangleCanvas"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="toggleCompression()">Toggle: Raw Storage vs Compressed</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 3: Orthogonal Representation -->
        <div class="slide" id="slide3">
            <div class="slide-content">
                <h2 class="slide-title">Orthogonal Representation</h2>
                <div class="left-panel">
                    <div class="info-box">
                        <p>Every aspect of a system that is <span class="highlight">orthogonal</span> (independent) can be represented separately.</p>
                        <p style="margin-top: 1rem;">Similar to eigenvectors - finding the most efficient basis for representing information.</p>
                    </div>
                    
                    <div class="parameter">
                        <label>Color Dimension:</label>
                        <span id="colorValue" style="color: #a78bfa;">RGB(120, 80, 200)</span>
                    </div>
                    <div class="parameter">
                        <label>Size Dimension:</label>
                        <span id="sizeValue" style="color: #a78bfa;">15.3 units</span>
                    </div>
                    <div class="parameter">
                        <label>Pattern Frequency:</label>
                        <span id="frequencyValue" style="color: #a78bfa;">0.73</span>
                    </div>
                    <div class="parameter">
                        <label>Spatial Distribution:</label>
                        <span id="spatialValue" style="color: #a78bfa;">Gaussian(μ=0.5, σ=0.2)</span>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="visualization">
                        <canvas id="eigenCanvas"></canvas>
                    </div>
                    
                    <div class="controls">
                        <button onclick="animateEigenDecomposition()">Decompose to Orthogonal</button>
                        <button onclick="reconstructFromEigen()">Reset to Original</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Level of Detail with Cell Example -->
        <div class="slide" id="slide4">
            <div class="slide-content">
                <h2 class="slide-title">Idea 2: Adaptive Level of Detail</h2>
                <div class="left-panel">
                    <div class="info-box">
                        <p>Part of intelligence means knowing <span class="highlight">what level of detail</span> you need to solve a problem.</p>
                        <p style="margin-top: 1rem;">Example: Modeling a biological cell</p>
                        <p style="margin-top: 0.5rem; color: #a78bfa;">From billions of DNA base pairs to just the parameters you need.</p>
                    </div>

                    <div class="info-box" style="margin-top: 1.5rem;">
                        <h3 id="lodTitle">Cellular Level</h3>
                        <p id="lodDescription">Viewing whole cell structure and major organelles.</p>
                        <div class="parameter">
                            <label>Parameters Used:</label>
                            <span id="paramCount" style="color: #a78bfa;">1,000</span>
                        </div>
                        <div class="parameter">
                            <label>View Level:</label>
                            <span id="viewLevel" style="color: #a78bfa;">Cell Overview</span>
                        </div>
                    </div>

                    <div class="compression-comparison" style="display: grid; grid-template-columns: 1fr; gap: 0.6rem; margin-top: 1rem;">
                        <div class="comparison-box">
                            <h3>Task-Based Detail Selection</h3>
                            <div style="font-size: 0.85rem; line-height: 1.6;">
                                <p><strong>Level 1-3: Cell Type</strong><br>
                                <span style="color: #a78bfa; font-size: 0.8rem;">Shape, size, basic structure<br>100-1,000 parameters</span></p>
                                <p style="margin-top: 0.5rem;"><strong>Level 4-7: Organelle Analysis</strong><br>
                                <span style="color: #a78bfa; font-size: 0.8rem;">Mitochondria, nucleus, ER detail<br>1,000-10,000 parameters</span></p>
                                <p style="margin-top: 0.5rem;"><strong>Level 8-10: Molecular Dynamics</strong><br>
                                <span style="color: #a78bfa; font-size: 0.8rem;">Proteins, DNA, chemical reactions<br>10,000-100,000 parameters</span></p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="right-panel">
                    <div class="visualization">
                        <canvas id="lodCanvas"></canvas>
                    </div>

                    <div class="slider-container">
                        <label>Detail Level: <span id="lodValue">8</span></label>
                        <input type="range" id="lodSlider" min="1" max="15" value="8" oninput="updateLOD(this.value)">
                    </div>

                    <div id="compressionParams" style="margin-top: 15px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 5px; font-size: 12px; min-height: 80px;">
                        <strong>Compression Parameters:</strong>
                        <div id="paramDisplay" style="margin-top: 5px; color: #6b7280;"></div>
                        <div id="errorThreshold" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(99, 102, 241, 0.2);"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: The Future -->
        <div class="slide" id="slide5">
            <div class="slide-content">
                <h2 class="slide-title">The Path to AGI</h2>
                <div class="left-panel">
                    <div class="info-box">
                        <p>Combine <span class="highlight">optimal compression</span> with <span class="highlight">adaptive complexity</span></p>
                        <p style="margin-top: 1rem;">Result: AI that can efficiently model any system at the right level of detail</p>
                    </div>
                    
                    <div class="comparison-box">
                        <h3>Current AI (LLMs)</h3>
                        <ul style="text-align: left;">
                            <li>Brute force compression</li>
                            <li>Billions of parameters</li>
                            <li>Fixed level of detail</li>
                            <li>Context-limited understanding</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-box" style="margin-top: 1rem;">
                        <h3>Next-Gen AI</h3>
                        <ul style="text-align: left;">
                            <li>Optimal orthogonal representation</li>
                            <li>Dynamic parameter allocation</li>
                            <li>Adaptive detail levels</li>
                            <li>On-demand model creation</li>
                        </ul>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="info-box">
                        <h3>Key Innovations Needed</h3>
                        <ul style="text-align: left; list-style: none;">
                            <li>• Training models to find optimal compressions</li>
                            <li>• Agents that create models on-demand</li>
                            <li>• Dynamic complexity adjustment based on feedback</li>
                            <li>• Integration of multiple representation levels</li>
                        </ul>
                    </div>
                    
                    <div class="info-box" style="margin-top: 1rem;">
                        <h3>The Vision</h3>
                        <p>With these algorithms in place, the path to AGI becomes clearer.</p>
                        <p style="margin-top: 0.5rem;">The combination of optimal knowledge compression and adaptive complexity could enable AI systems that truly understand and model the world at any required level of detail.</p>
                        <p style="margin-top: 0.8rem; font-style: italic; color: #a78bfa;">
                            "When you see how you can go from billions of DNA pairs to just 10k numbers that describe the same complexity... it's pretty crazy."
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="navigation">
            <button class="nav-btn" onclick="previousSlide()">←</button>
            <button class="nav-btn" onclick="nextSlide()">→</button>
            <button class="nav-btn restart-btn" onclick="location.reload()" style="display: none; opacity: 0;" title="Restart Presentation">⟲</button>
        </div>
    </div>

    <script>
        // Ensure console methods exist to prevent errors
        if (typeof console === 'undefined') {
            window.console = { log: function() {}, debug: function() {} };
        } else {
            if (!console.debug) console.debug = console.log || function() {};
        }
        
        let currentSlide = 1;
        const totalSlides = 5;
        let compressionView = false;
        let triangles = [];
        let animationFrame;
        let navigationTimeout;

        // Mobile touch handling variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let isSwiping = false;
        let swipeThreshold = 50;
        let scrollThreshold = 10;

        function nextSlide() {
            if (currentSlide < totalSlides) {
                if (navigationTimeout) {
                    clearTimeout(navigationTimeout);
                    navigationTimeout = null;
                }
                const currentSlideEl = document.getElementById(`slide${currentSlide}`);
                currentSlideEl.classList.remove('active');
                currentSlideEl.style.display = 'none';
                currentSlide++;
                const nextSlideEl = document.getElementById(`slide${currentSlide}`);
                nextSlideEl.classList.add('active');
                nextSlideEl.style.display = 'flex';
                nextSlideEl.style.opacity = '0';
                nextSlideEl.scrollTop = 0; // Reset scroll to top
                setTimeout(() => nextSlideEl.style.opacity = '1', 10);
                initializeSlide(currentSlide);
                updateNavButtons();
                // Show navigation immediately on other slides
                showNavigation();
            }
        }

        function previousSlide() {
            if (currentSlide > 1) {
                if (navigationTimeout) {
                    clearTimeout(navigationTimeout);
                    navigationTimeout = null;
                }
                const currentSlideEl = document.getElementById(`slide${currentSlide}`);
                currentSlideEl.classList.remove('active');
                currentSlideEl.style.display = 'none';
                currentSlide--;
                const prevSlideEl = document.getElementById(`slide${currentSlide}`);
                prevSlideEl.classList.add('active');
                prevSlideEl.style.display = 'flex';
                prevSlideEl.style.opacity = '0';
                prevSlideEl.scrollTop = 0; // Reset scroll to top
                setTimeout(() => prevSlideEl.style.opacity = '1', 10);
                initializeSlide(currentSlide);
                updateNavButtons();
                // Show navigation immediately when going back
                showNavigation();
            }
        }
        
        function showNavigation() {
            const nav = document.querySelector('.navigation');
            if (nav) {
                nav.classList.add('visible');
            }
            // Also show the navigation hint on first slide
            if (currentSlide === 1) {
                const hint = document.getElementById('navHint');
                if (hint) {
                    hint.style.opacity = '0.6';
                }
            }
        }

        
        function updateNavButtons() {
            const navButtons = document.querySelectorAll('.nav-btn');
            if (navButtons.length >= 3) {
                const backBtn = navButtons[0];
                const forwardBtn = navButtons[1];
                const restartBtn = navButtons[2];
                
                backBtn.style.display = currentSlide === 1 ? 'none' : 'flex';
                forwardBtn.style.display = currentSlide === totalSlides ? 'none' : 'flex';
                
                // Show restart button on last slide with animation
                if (currentSlide === totalSlides) {
                    restartBtn.style.display = 'flex';
                    setTimeout(() => {
                        restartBtn.style.opacity = '1';
                    }, 100);
                } else {
                    restartBtn.style.opacity = '0';
                    setTimeout(() => {
                        restartBtn.style.display = 'none';
                    }, 300);
                }
            }
        }

        function initializeSlide(slideNum) {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Small delay to ensure DOM is ready
            setTimeout(() => {
                switch(slideNum) {
                    case 1:
                        // First slide - no special initialization needed
                        break;
                    case 2:
                        initTriangleVisualization();
                        break;
                    case 3:
                        initEigenVisualization();
                        break;
                    case 4:
                        initLODCellVisualization();
                        break;
                    case 5:
                        // Last slide - no special initialization needed
                        break;
                }
            }, 50);
        }

        function initTriangleVisualization() {
            compressionView = false; // Reset to default view
            const canvas = document.getElementById('triangleCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            generateTriangles();
            drawTriangles(ctx);
        }

        function generateTriangles() {
            triangles = [];
            const count = 1000;
            const size = 8;
            const canvas = document.getElementById('triangleCanvas');
            const canvasWidth = canvas ? canvas.offsetWidth : 800;
            const canvasHeight = canvas ? canvas.offsetHeight : 400;
            
            for (let i = 0; i < count; i++) {
                triangles.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    size: size + (Math.random() - 0.5) * 2,
                    rotation: Math.random() * Math.PI * 2,
                    color: `hsl(${260 + Math.random() * 40}, 70%, ${50 + Math.random() * 20}%)`
                });
            }
        }

        function drawTriangles(ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (compressionView) {
                // Generate triangles from compressed parameters
                const compressedParams = {
                    triangleSize: 8,
                    count: 1000,
                    distribution: 'uniform_random',
                    spacing: 25,
                    colorHue: { min: 260, max: 300 },
                    rotation: { min: 0, max: 2 * Math.PI },
                    seed: 42 // For reproducibility
                };
                
                // Use a seeded random for reproducible patterns
                let seed = compressedParams.seed;
                function seededRandom() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                }
                
                // Generate and draw triangles from compressed representation
                for (let i = 0; i < compressedParams.count; i++) {
                    const x = seededRandom() * ctx.canvas.width;
                    const y = seededRandom() * ctx.canvas.height;
                    const size = compressedParams.triangleSize + (seededRandom() - 0.5) * 2;
                    const rotation = compressedParams.rotation.min + seededRandom() * (compressedParams.rotation.max - compressedParams.rotation.min);
                    const hue = compressedParams.colorHue.min + seededRandom() * (compressedParams.colorHue.max - compressedParams.colorHue.min);
                    const color = `hsl(${hue}, 70%, ${50 + seededRandom() * 20}%)`;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.7;
                    drawTriangle(ctx, 0, 0, size, 0);
                    ctx.restore();
                }
                
                // Overlay the parameter display
                ctx.fillStyle = 'rgba(15, 15, 35, 0.9)';
                ctx.fillRect(10, 10, 280, 180);
                
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 18px monospace';
                ctx.fillText('Generated from:', 20, 35);
                ctx.font = '14px monospace';
                ctx.fillStyle = '#a78bfa';
                ctx.fillText(`triangleSize: ${compressedParams.triangleSize}`, 20, 60);
                ctx.fillText(`count: ${compressedParams.count}`, 20, 80);
                ctx.fillText(`distribution: ${compressedParams.distribution}`, 20, 100);
                ctx.fillText(`spacing: ~${compressedParams.spacing}px`, 20, 120);
                ctx.fillText(`colorHue: ${compressedParams.colorHue.min}-${compressedParams.colorHue.max}`, 20, 140);
                ctx.fillText(`rotation: 0-2π`, 20, 160);
                ctx.fillText(`seed: ${compressedParams.seed}`, 20, 180);
                
                // Add a subtle border effect
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, 280, 180);
            } else {
                // Draw all triangles from raw storage
                triangles.forEach(t => {
                    ctx.save();
                    ctx.translate(t.x, t.y);
                    ctx.rotate(t.rotation);
                    ctx.fillStyle = t.color;
                    ctx.globalAlpha = 0.7;
                    drawTriangle(ctx, 0, 0, t.size, 0);
                    ctx.restore();
                });
                
                // Show storage info
                ctx.fillStyle = 'rgba(15, 15, 35, 0.9)';
                ctx.fillRect(10, 10, 200, 60);
                ctx.fillStyle = '#f093fb';
                ctx.font = 'bold 18px monospace';
                ctx.fillText('Raw Storage:', 20, 35);
                ctx.font = '14px monospace';
                ctx.fillStyle = '#a78bfa';
                ctx.fillText('6000 coordinates', 20, 55);
            }
        }

        function drawTriangle(ctx, x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(-size * 0.866, size * 0.5);
            ctx.lineTo(size * 0.866, size * 0.5);
            ctx.closePath();
            if (ctx.fillStyle) ctx.fill();
            if (ctx.strokeStyle) ctx.stroke();
            ctx.restore();
        }

        function regenerateTriangles() {
            compressionView = false; // Always show raw view when regenerating
            generateTriangles();
            const canvas = document.getElementById('triangleCanvas');
            const ctx = canvas.getContext('2d');
            
            // Add a brief flash effect
            canvas.style.opacity = '0.3';
            setTimeout(() => {
                drawTriangles(ctx);
                canvas.style.opacity = '1';
            }, 150);
        }

        function toggleCompression() {
            compressionView = !compressionView;
            const canvas = document.getElementById('triangleCanvas');
            const ctx = canvas.getContext('2d');
            
            // Add a brief transition effect
            canvas.style.opacity = '0.3';
            setTimeout(() => {
                drawTriangles(ctx);
                canvas.style.opacity = '1';
            }, 150);
        }

        let eigenAnimationState = 'redundant';
        let eigenAnimationProgress = 0;
        let dataPoints = [];

        function initEigenVisualization() {
            const canvas = document.getElementById('eigenCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Initialize data points with correlated (redundant) positions
            dataPoints = [];
            for (let i = 0; i < 100; i++) {
                const t = i / 100;
                const angle = t * Math.PI * 2;
                const radius = 30 + Math.random() * 80;
                const correlation = 0.8; // High correlation = redundancy
                dataPoints.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius * 0.4 + Math.cos(angle) * radius * correlation,
                    originalX: Math.cos(angle) * radius,
                    originalY: Math.sin(angle) * radius * 0.4 + Math.cos(angle) * radius * correlation,
                    color: `hsl(${260 + i * 1.4}, 70%, 60%)`,
                    eigenX: 0,
                    eigenY: 0
                });
            }

            // Calculate orthogonal representation
            dataPoints.forEach((p, i) => {
                // Project onto orthogonal axes
                const angle1 = -Math.PI / 6;
                const angle2 = angle1 + Math.PI / 2;

                // Project onto first eigenvector
                const proj1 = p.x * Math.cos(angle1) + p.y * Math.sin(angle1);
                // Project onto second eigenvector
                const proj2 = p.x * Math.cos(angle2) + p.y * Math.sin(angle2);

                p.eigenX = proj1 * Math.cos(angle1) + proj2 * Math.cos(angle2);
                p.eigenY = proj1 * Math.sin(angle1) + proj2 * Math.sin(angle2);
            });

            drawEigenSpace(ctx, 'redundant', 0);
        }

        function drawEigenSpace(ctx, state = 'redundant', progress = 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;

            // Draw title based on state
            ctx.fillStyle = '#a78bfa';
            ctx.font = 'bold 14px monospace';
            if (state === 'redundant') {
                ctx.fillText('Redundant Representation', 20, 25);
                ctx.font = '12px monospace';
                ctx.fillText('Data with correlated dimensions', 20, 45);
            } else if (state === 'decomposing') {
                ctx.fillText('Decomposing...', 20, 25);
                ctx.font = '12px monospace';
                ctx.fillText(`Finding orthogonal basis (${Math.round(progress * 100)}%)`, 20, 45);
            } else if (state === 'orthogonal') {
                ctx.fillText('Orthogonal Representation', 20, 25);
                ctx.font = '12px monospace';
                ctx.fillText('Independent dimensions extracted', 20, 45);
            }

            // Draw coordinate system
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(ctx.canvas.width - 50, centerY);
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, ctx.canvas.height - 50);
            ctx.stroke();

            // Draw axes labels
            ctx.fillStyle = 'rgba(102, 126, 234, 0.6)';
            ctx.font = '11px monospace';
            ctx.fillText('X', ctx.canvas.width - 45, centerY - 5);
            ctx.fillText('Y', centerX + 5, 55);

            // Draw eigenvectors (fade in during decomposition)
            const eigenAlpha = state === 'redundant' ? 0 : (state === 'decomposing' ? progress : 1);
            if (eigenAlpha > 0) {
                ctx.strokeStyle = `rgba(240, 147, 251, ${eigenAlpha})`;
                ctx.lineWidth = 3;

                const angle1 = -Math.PI / 6;
                const angle2 = angle1 + Math.PI / 2;
                const vecLength = 120;

                // First eigenvector
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle1) * vecLength, centerY + Math.sin(angle1) * vecLength);
                ctx.stroke();

                // Arrow for first eigenvector
                ctx.beginPath();
                const arrow1X = centerX + Math.cos(angle1) * vecLength;
                const arrow1Y = centerY + Math.sin(angle1) * vecLength;
                ctx.moveTo(arrow1X, arrow1Y);
                ctx.lineTo(arrow1X - 10 * Math.cos(angle1 - 0.3), arrow1Y - 10 * Math.sin(angle1 - 0.3));
                ctx.moveTo(arrow1X, arrow1Y);
                ctx.lineTo(arrow1X - 10 * Math.cos(angle1 + 0.3), arrow1Y - 10 * Math.sin(angle1 + 0.3));
                ctx.stroke();

                // Second eigenvector
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle2) * vecLength, centerY + Math.sin(angle2) * vecLength);
                ctx.stroke();

                // Arrow for second eigenvector
                ctx.beginPath();
                const arrow2X = centerX + Math.cos(angle2) * vecLength;
                const arrow2Y = centerY + Math.sin(angle2) * vecLength;
                ctx.moveTo(arrow2X, arrow2Y);
                ctx.lineTo(arrow2X - 10 * Math.cos(angle2 - 0.3), arrow2Y - 10 * Math.sin(angle2 - 0.3));
                ctx.moveTo(arrow2X, arrow2Y);
                ctx.lineTo(arrow2X - 10 * Math.cos(angle2 + 0.3), arrow2Y - 10 * Math.sin(angle2 + 0.3));
                ctx.stroke();

                // Labels for eigenvectors
                ctx.fillStyle = `rgba(240, 147, 251, ${eigenAlpha})`;
                ctx.font = 'bold 12px monospace';
                ctx.fillText('PC1', arrow1X + 10, arrow1Y);
                ctx.fillText('PC2', arrow2X + 10, arrow2Y);
            }

            // Draw data points
            dataPoints.forEach((point, i) => {
                let x, y;
                if (state === 'redundant') {
                    x = centerX + point.originalX;
                    y = centerY + point.originalY;
                } else if (state === 'decomposing') {
                    // Interpolate between original and orthogonal positions
                    x = centerX + point.originalX * (1 - progress) + point.eigenX * progress;
                    y = centerY + point.originalY * (1 - progress) + point.eigenY * progress;
                } else {
                    x = centerX + point.eigenX;
                    y = centerY + point.eigenY;
                }

                ctx.fillStyle = point.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw projection lines during decomposition
                if (state === 'decomposing' && progress > 0.3 && progress < 0.9 && i % 10 === 0) {
                    ctx.strokeStyle = `rgba(102, 126, 234, ${(progress - 0.3) * 0.3})`;
                    ctx.lineWidth = 0.5;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(centerX + point.originalX, centerY + point.originalY);
                    ctx.lineTo(centerX + point.eigenX, centerY + point.eigenY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });

            ctx.globalAlpha = 1;

            // Show correlation indicator
            if (state === 'redundant') {
                ctx.fillStyle = 'rgba(239, 68, 68, 0.6)';
                ctx.font = '12px monospace';
                ctx.fillText('High correlation', ctx.canvas.width - 140, ctx.canvas.height - 20);
                ctx.fillText('(redundancy)', ctx.canvas.width - 140, ctx.canvas.height - 5);
            } else if (state === 'orthogonal') {
                ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
                ctx.font = '12px monospace';
                ctx.fillText('Zero correlation', ctx.canvas.width - 140, ctx.canvas.height - 20);
                ctx.fillText('(independent)', ctx.canvas.width - 140, ctx.canvas.height - 5);
            }
        }

        function animateEigenDecomposition() {
            const canvas = document.getElementById('eigenCanvas');
            const ctx = canvas.getContext('2d');

            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }

            eigenAnimationState = 'decomposing';
            eigenAnimationProgress = 0;

            function animate() {
                eigenAnimationProgress += 0.015;

                if (eigenAnimationProgress >= 1) {
                    eigenAnimationProgress = 1;
                    eigenAnimationState = 'orthogonal';
                    drawEigenSpace(ctx, eigenAnimationState, eigenAnimationProgress);

                    // Update the parameter values to show the transformation
                    setTimeout(() => {
                        document.getElementById('colorValue').textContent = 'PC1: 0.82';
                        document.getElementById('sizeValue').textContent = 'PC2: 0.15';
                        document.getElementById('frequencyValue').textContent = 'Variance: 85%';
                        document.getElementById('spatialValue').textContent = 'Variance: 15%';
                    }, 500);
                    return;
                }

                drawEigenSpace(ctx, eigenAnimationState, eigenAnimationProgress);
                animationFrame = requestAnimationFrame(animate);
            }

            animate();
        }

        function reconstructFromEigen() {
            const canvas = document.getElementById('eigenCanvas');
            const ctx = canvas.getContext('2d');

            // Reset to redundant state
            eigenAnimationState = 'redundant';
            eigenAnimationProgress = 0;
            drawEigenSpace(ctx, eigenAnimationState, eigenAnimationProgress);

            // Reset parameter values
            const values = [
                { id: 'colorValue', text: 'RGB(120, 80, 200)' },
                { id: 'sizeValue', text: '15.3 units' },
                { id: 'frequencyValue', text: '0.73' },
                { id: 'spatialValue', text: 'Gaussian(μ=0.5, σ=0.2)' }
            ];

            values.forEach((v, i) => {
                const el = document.getElementById(v.id);
                if (el) {
                    el.textContent = v.text;
                    el.style.color = '#a78bfa';
                }
            });
        }

        let animationFrameId = null;

        function initLODCellVisualization() {
            const canvas = document.getElementById('lodCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            drawFlowerAtLOD(ctx, 8);
            updateCompressionDisplay(8);
        }

        function drawFlowerAtLOD(ctx, level) {
            // Cancel any existing animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;

            // 15 levels from simple flower to molecular dynamics
            if (level === 1) {
                // Level 1: Simple flower icon
                drawSimpleFlowerIcon(ctx, centerX, centerY);
            } else if (level === 2) {
                // Level 2: Flower with distinct petals
                drawFlowerWithPetals(ctx, centerX, centerY);
            } else if (level === 3) {
                // Level 3: Flower with surface texture
                drawFlowerWithTexture(ctx, centerX, centerY);
            } else if (level === 4) {
                // Level 4: Flower showing cell boundaries
                drawFlowerWithCells(ctx, centerX, centerY);
            } else if (level === 5) {
                // Level 5: Plant tissue structure
                drawPlantTissue(ctx, centerX, centerY);
            } else if (level === 6) {
                // Level 6: Individual plant cells
                drawPlantCells(ctx, centerX, centerY);
            } else if (level === 7) {
                // Level 7: Detailed cell structure with organelles
                drawDetailedPlantCell(ctx, centerX, centerY);
            } else if (level === 8) {
                // Level 8: Chloroplast detail
                drawChloroplastDetail(ctx, centerX, centerY);
            } else if (level === 9) {
                // Level 9: Cell membrane detail
                drawMembraneDetail(ctx, centerX, centerY);
            } else if (level === 10) {
                // Level 10: Protein complexes
                drawProteinComplexes(ctx, centerX, centerY);
            } else if (level === 11) {
                // Level 11: Molecular machinery
                drawMolecularMachinery(ctx, centerX, centerY);
            } else if (level === 12) {
                // Level 12: Amino acid chains
                drawAminoAcidChains(ctx, centerX, centerY);
            } else if (level === 13) {
                // Level 13: Atomic structure
                drawAtomicStructure(ctx, centerX, centerY);
            } else if (level === 14) {
                // Level 14: Electron orbitals
                drawElectronOrbitals(ctx, centerX, centerY);
            } else {
                // Level 15: Molecular dynamics
                drawMolecularDynamics(ctx, centerX, centerY);
            }
        }

        // Level 1: Simple flower icon
        function drawSimpleFlowerIcon(ctx, centerX, centerY) {
            // Basic flower circle
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20, 40, 0, Math.PI * 2);
            ctx.fill();

            // Simple stem
            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + 20);
            ctx.lineTo(centerX, centerY + 100);
            ctx.stroke();
        }

        // Level 2: Flower with distinct petals
        function drawFlowerWithPetals(ctx, centerX, centerY) {
            // Draw 6 petals
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const petalX = centerX + Math.cos(angle) * 25;
                const petalY = centerY - 20 + Math.sin(angle) * 25;

                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.ellipse(petalX, petalY, 25, 15, angle, 0, Math.PI * 2);
                ctx.fill();
            }

            // Center
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20, 15, 0, Math.PI * 2);
            ctx.fill();

            // Stem with leaves
            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + 10);
            ctx.lineTo(centerX, centerY + 100);
            ctx.stroke();

            // Simple leaves
            ctx.fillStyle = '#16a34a';
            ctx.beginPath();
            ctx.ellipse(centerX - 15, centerY + 50, 10, 5, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + 15, centerY + 70, 10, 5, 0.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Level 3: Flower with surface texture
        function drawFlowerWithTexture(ctx, centerX, centerY) {
            // Textured petals
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const petalX = centerX + Math.cos(angle) * 30;
                const petalY = centerY - 20 + Math.sin(angle) * 30;

                // Petal gradient
                const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 25);
                gradient.addColorStop(0, '#fde047');
                gradient.addColorStop(0.7, '#fbbf24');
                gradient.addColorStop(1, '#f59e0b');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(petalX, petalY, 28, 18, angle, 0, Math.PI * 2);
                ctx.fill();

                // Petal veins
                ctx.strokeStyle = 'rgba(245, 158, 11, 0.5)';
                ctx.lineWidth = 0.5;
                for (let v = 0; v < 3; v++) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - 20);
                    const vAngle = angle + (v - 1) * 0.2;
                    ctx.lineTo(
                        centerX + Math.cos(vAngle) * 45,
                        centerY - 20 + Math.sin(vAngle) * 45
                    );
                    ctx.stroke();
                }
            }

            // Textured center
            for (let r = 0; r < 5; r++) {
                ctx.fillStyle = `rgba(245, 158, 11, ${0.8 - r * 0.15})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 15 - r * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Detailed stem
            const stemGradient = ctx.createLinearGradient(centerX - 3, 0, centerX + 3, 0);
            stemGradient.addColorStop(0, '#059669');
            stemGradient.addColorStop(0.5, '#16a34a');
            stemGradient.addColorStop(1, '#059669');
            ctx.strokeStyle = stemGradient;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + 10);
            ctx.lineTo(centerX, centerY + 100);
            ctx.stroke();
        }

        // Level 4: Flower showing cell boundaries
        function drawFlowerWithCells(ctx, centerX, centerY) {
            // Draw petal with visible cells
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const petalX = centerX + Math.cos(angle) * 30;
                const petalY = centerY - 20 + Math.sin(angle) * 30;

                // Draw cells in petal
                for (let cx = -25; cx < 25; cx += 8) {
                    for (let cy = -15; cy < 15; cy += 8) {
                        const cellX = petalX + cx;
                        const cellY = petalY + cy;

                        // Check if inside petal
                        const dx = (cellX - petalX) / 28;
                        const dy = (cellY - petalY) / 18;
                        if (dx * dx + dy * dy <= 1) {
                            ctx.strokeStyle = 'rgba(245, 158, 11, 0.6)';
                            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
                            ctx.lineWidth = 0.5;

                            // Hexagonal cells
                            ctx.beginPath();
                            for (let v = 0; v < 6; v++) {
                                const vAngle = (v / 6) * Math.PI * 2;
                                const vx = cellX + Math.cos(vAngle) * 4;
                                const vy = cellY + Math.sin(vAngle) * 4;
                                if (v === 0) ctx.moveTo(vx, vy);
                                else ctx.lineTo(vx, vy);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Level 5: Plant tissue structure
        function drawPlantTissue(ctx, centerX, centerY) {
            // Cross-section of petal tissue
            const tissueWidth = 200;
            const tissueHeight = 150;
            const startX = centerX - tissueWidth / 2;
            const startY = centerY - tissueHeight / 2;

            // Epidermis (outer layer)
            ctx.fillStyle = 'rgba(254, 240, 138, 0.9)';
            ctx.fillRect(startX, startY, tissueWidth, 20);

            // Draw epidermal cells
            for (let x = 0; x < tissueWidth; x += 15) {
                ctx.strokeStyle = 'rgba(245, 158, 11, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.rect(startX + x, startY, 15, 20);
                ctx.stroke();
            }

            // Palisade mesophyll
            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
            for (let x = 0; x < tissueWidth; x += 12) {
                for (let y = 0; y < 40; y += 35) {
                    ctx.beginPath();
                    ctx.rect(startX + x + 1, startY + 25 + y, 10, 30);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(245, 158, 11, 0.6)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();

                    // Chloroplasts
                    for (let c = 0; c < 3; c++) {
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
                        ctx.beginPath();
                        ctx.ellipse(
                            startX + x + 6,
                            startY + 30 + c * 8,
                            3, 2, 0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }

            // Spongy mesophyll
            for (let i = 0; i < 30; i++) {
                const x = startX + Math.random() * tissueWidth;
                const y = startY + 70 + Math.random() * 50;
                const size = 8 + Math.random() * 8;

                ctx.fillStyle = 'rgba(251, 191, 36, 0.6)';
                ctx.strokeStyle = 'rgba(245, 158, 11, 0.5)';
                ctx.lineWidth = 0.5;

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Air spaces
                if (Math.random() > 0.5) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x + size/2, y, size/3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Lower epidermis
            ctx.fillStyle = 'rgba(254, 240, 138, 0.9)';
            ctx.fillRect(startX, startY + 130, tissueWidth, 20);

            // Stomata
            for (let s = 0; s < 3; s++) {
                const stX = startX + 30 + s * 60;
                const stY = startY + 140;

                // Guard cells
                ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                ctx.beginPath();
                ctx.ellipse(stX - 4, stY, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(stX + 4, stY, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pore
                ctx.strokeStyle = '#1f2937';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(stX, stY - 4);
                ctx.lineTo(stX, stY + 4);
                ctx.stroke();
            }
        }

        // Level 6: Individual plant cells
        function drawPlantCells(ctx, centerX, centerY) {
            // Draw a few plant cells in detail
            const cells = [
                { x: centerX - 50, y: centerY, size: 40 },
                { x: centerX + 50, y: centerY, size: 40 },
                { x: centerX, y: centerY - 50, size: 35 },
                { x: centerX, y: centerY + 50, size: 35 }
            ];

            cells.forEach(cell => {
                // Cell wall
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 3;
                ctx.fillStyle = 'rgba(254, 243, 199, 0.3)';
                ctx.beginPath();
                ctx.rect(cell.x - cell.size, cell.y - cell.size, cell.size * 2, cell.size * 2);
                ctx.fill();
                ctx.stroke();

                // Cell membrane
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.rect(
                    cell.x - cell.size + 3,
                    cell.y - cell.size + 3,
                    cell.size * 2 - 6,
                    cell.size * 2 - 6
                );
                ctx.stroke();
                ctx.setLineDash([]);

                // Cytoplasm
                ctx.fillStyle = 'rgba(187, 247, 208, 0.2)';
                ctx.fillRect(
                    cell.x - cell.size + 5,
                    cell.y - cell.size + 5,
                    cell.size * 2 - 10,
                    cell.size * 2 - 10
                );

                // Central vacuole
                ctx.fillStyle = 'rgba(147, 197, 253, 0.3)';
                ctx.beginPath();
                ctx.ellipse(cell.x, cell.y, cell.size * 0.6, cell.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Nucleus
                ctx.fillStyle = 'rgba(139, 92, 246, 0.6)';
                ctx.beginPath();
                ctx.arc(cell.x - cell.size * 0.4, cell.y - cell.size * 0.3, cell.size * 0.15, 0, Math.PI * 2);
                ctx.fill();

                // Chloroplasts
                for (let c = 0; c < 5; c++) {
                    const angle = (c / 5) * Math.PI * 2;
                    const cx = cell.x + Math.cos(angle) * cell.size * 0.5;
                    const cy = cell.y + Math.sin(angle) * cell.size * 0.5;

                    ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, 5, 3, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Level 7: Detailed cell structure with organelles
        function drawDetailedPlantCell(ctx, centerX, centerY) {
            const cellSize = 100;

            // Cell wall
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 4;
            ctx.fillStyle = 'rgba(254, 249, 195, 0.2)';
            ctx.beginPath();
            ctx.rect(centerX - cellSize, centerY - cellSize, cellSize * 2, cellSize * 2);
            ctx.fill();
            ctx.stroke();

            // Cell membrane (phospholipid bilayer hint)
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.rect(centerX - cellSize + 5, centerY - cellSize + 5, cellSize * 2 - 10, cellSize * 2 - 10);
            ctx.stroke();
            ctx.setLineDash([]);

            // Cytoplasm
            const cytoGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, cellSize);
            cytoGradient.addColorStop(0, 'rgba(187, 247, 208, 0.1)');
            cytoGradient.addColorStop(1, 'rgba(187, 247, 208, 0.3)');
            ctx.fillStyle = cytoGradient;
            ctx.fillRect(centerX - cellSize + 8, centerY - cellSize + 8, cellSize * 2 - 16, cellSize * 2 - 16);

            // Central vacuole with tonoplast
            ctx.fillStyle = 'rgba(147, 197, 253, 0.4)';
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(centerX + 20, centerY + 10, 50, 40, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Nucleus with nucleolus and nuclear envelope
            const nucleusX = centerX - 30;
            const nucleusY = centerY - 20;

            // Nuclear envelope (double membrane)
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(nucleusX, nucleusY, 25, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
            ctx.beginPath();
            ctx.arc(nucleusX, nucleusY, 23, 0, Math.PI * 2);
            ctx.fill();

            // Nucleolus
            ctx.fillStyle = 'rgba(79, 70, 229, 0.8)';
            ctx.beginPath();
            ctx.arc(nucleusX + 5, nucleusY - 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Chromatin
            ctx.strokeStyle = 'rgba(79, 70, 229, 0.4)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(nucleusX + Math.random() * 20 - 10, nucleusY + Math.random() * 20 - 10);
                ctx.quadraticCurveTo(
                    nucleusX + Math.random() * 20 - 10,
                    nucleusY + Math.random() * 20 - 10,
                    nucleusX + Math.random() * 20 - 10,
                    nucleusY + Math.random() * 20 - 10
                );
                ctx.stroke();
            }

            // Chloroplasts with thylakoids
            const chloroplasts = [
                { x: centerX - 50, y: centerY + 40, angle: 0.3 },
                { x: centerX + 40, y: centerY - 50, angle: -0.5 },
                { x: centerX - 20, y: centerY + 60, angle: 0.8 },
                { x: centerX + 60, y: centerY + 20, angle: -0.2 }
            ];

            chloroplasts.forEach(chloro => {
                ctx.save();
                ctx.translate(chloro.x, chloro.y);
                ctx.rotate(chloro.angle);

                // Outer membrane
                ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thylakoid stacks (grana)
                ctx.fillStyle = 'rgba(22, 163, 74, 0.9)';
                for (let t = -8; t < 8; t += 3) {
                    ctx.beginPath();
                    ctx.rect(t, -4, 2, 8);
                    ctx.fill();
                }

                ctx.restore();
            });

            // Mitochondria
            const mitochondria = [
                { x: centerX + 30, y: centerY - 30 },
                { x: centerX - 60, y: centerY - 10 }
            ];

            mitochondria.forEach(mito => {
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.beginPath();
                ctx.ellipse(mito.x, mito.y, 15, 8, 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Cristae
                ctx.strokeStyle = 'rgba(185, 28, 28, 0.7)';
                ctx.lineWidth = 1;
                for (let c = -10; c < 10; c += 4) {
                    ctx.beginPath();
                    ctx.moveTo(mito.x + c, mito.y - 5);
                    ctx.lineTo(mito.x + c + 2, mito.y + 5);
                    ctx.stroke();
                }
            });

            // Endoplasmic reticulum
            ctx.strokeStyle = 'rgba(251, 146, 60, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 70, centerY + 20);
            ctx.quadraticCurveTo(centerX - 40, centerY + 30, centerX - 10, centerY + 25);
            ctx.quadraticCurveTo(centerX + 20, centerY + 20, centerX + 50, centerY + 35);
            ctx.stroke();

            // Ribosomes on ER
            for (let r = 0; r < 8; r++) {
                const t = r / 8;
                const rx = centerX - 70 + t * 120;
                const ry = centerY + 25 + Math.sin(t * Math.PI * 2) * 5;

                ctx.fillStyle = 'rgba(251, 146, 60, 0.9)';
                ctx.beginPath();
                ctx.arc(rx, ry, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Golgi apparatus
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.7)';
            ctx.lineWidth = 2;
            for (let g = 0; g < 4; g++) {
                ctx.beginPath();
                ctx.moveTo(centerX + 10, centerY - 60 + g * 5);
                ctx.quadraticCurveTo(
                    centerX + 25, centerY - 58 + g * 5,
                    centerX + 40, centerY - 60 + g * 5
                );
                ctx.stroke();
            }

            // Peroxisomes
            ctx.fillStyle = 'rgba(234, 179, 8, 0.6)';
            ctx.beginPath();
            ctx.arc(centerX - 40, centerY - 50, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 70, centerY, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Level 8: Chloroplast detail
        function drawChloroplastDetail(ctx, centerX, centerY) {
            // Large chloroplast cross-section
            const width = 180;
            const height = 120;

            // Outer membrane
            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(187, 247, 208, 0.2)';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, width/2, height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Inner membrane
            ctx.strokeStyle = '#15803d';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 2]);
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, width/2 - 5, height/2 - 5, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Stroma
            ctx.fillStyle = 'rgba(220, 252, 231, 0.5)';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, width/2 - 8, height/2 - 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Thylakoid membrane system
            // Grana stacks
            const granaPositions = [
                { x: centerX - 40, y: centerY - 20 },
                { x: centerX + 30, y: centerY - 15 },
                { x: centerX - 20, y: centerY + 20 },
                { x: centerX + 50, y: centerY + 25 },
                { x: centerX, y: centerY }
            ];

            granaPositions.forEach(pos => {
                // Stack of thylakoids
                for (let t = 0; t < 6; t++) {
                    const yOffset = t * 4;

                    // Thylakoid disc
                    ctx.fillStyle = `rgba(5, 150, 105, ${0.9 - t * 0.1})`;
                    ctx.beginPath();
                    ctx.ellipse(pos.x, pos.y + yOffset, 20, 3, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Lumen space
                    ctx.strokeStyle = 'rgba(6, 95, 70, 0.8)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }

                // Photosystem II complexes
                ctx.fillStyle = '#dc2626';
                for (let p = 0; p < 3; p++) {
                    ctx.beginPath();
                    ctx.arc(pos.x - 10 + p * 10, pos.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Photosystem I complexes
                ctx.fillStyle = '#2563eb';
                for (let p = 0; p < 3; p++) {
                    ctx.beginPath();
                    ctx.arc(pos.x - 10 + p * 10, pos.y + 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Stroma lamellae (connecting grana)
            ctx.strokeStyle = 'rgba(5, 150, 105, 0.5)';
            ctx.lineWidth = 2;

            // Connect grana with stroma lamellae
            ctx.beginPath();
            ctx.moveTo(granaPositions[0].x + 20, granaPositions[0].y);
            ctx.quadraticCurveTo(
                centerX, centerY - 10,
                granaPositions[1].x - 20, granaPositions[1].y
            );
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(granaPositions[2].x + 20, granaPositions[2].y);
            ctx.quadraticCurveTo(
                centerX + 20, centerY + 15,
                granaPositions[3].x - 20, granaPositions[3].y
            );
            ctx.stroke();

            // Starch grains
            ctx.fillStyle = 'rgba(254, 240, 138, 0.7)';
            ctx.beginPath();
            ctx.ellipse(centerX - 60, centerY + 30, 12, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + 60, centerY - 35, 10, 7, -0.4, 0, Math.PI * 2);
            ctx.fill();

            // Plastoglobuli (lipid droplets)
            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
            for (let i = 0; i < 8; i++) {
                const px = centerX - 70 + Math.random() * 140;
                const py = centerY - 50 + Math.random() * 100;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // DNA regions
            ctx.strokeStyle = 'rgba(147, 51, 234, 0.4)';
            ctx.lineWidth = 1;
            for (let d = 0; d < 3; d++) {
                ctx.beginPath();
                const dx = centerX - 50 + d * 50;
                const dy = centerY - 40 + d * 30;
                ctx.arc(dx, dy, 8, 0, Math.PI * 2);
                ctx.stroke();
            }

            // ATP synthase complexes on thylakoid
            ctx.fillStyle = '#f59e0b';
            granaPositions.forEach(pos => {
                for (let a = 0; a < 2; a++) {
                    ctx.beginPath();
                    ctx.arc(pos.x - 5 + a * 10, pos.y + 15, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Stalk
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(pos.x - 5 + a * 10, pos.y + 12);
                    ctx.lineTo(pos.x - 5 + a * 10, pos.y + 18);
                    ctx.stroke();
                }
            });
        }

        // Level 9: Cell membrane detail
        function drawMembraneDetail(ctx, centerX, centerY) {
            // Phospholipid bilayer close-up
            const membraneWidth = 250;
            const membraneHeight = 100;
            const startX = centerX - membraneWidth / 2;
            const startY = centerY - membraneHeight / 2;

            // Draw phospholipid bilayer
            for (let row = 0; row < 2; row++) {
                for (let i = 0; i < 25; i++) {
                    const x = startX + i * 10 + (row % 2) * 5;
                    const y = startY + membraneHeight / 2 + (row === 0 ? -15 : 15);

                    // Phosphate head
                    ctx.fillStyle = row === 0 ? '#3b82f6' : '#8b5cf6';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Fatty acid tails
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;

                    // Tail 1
                    ctx.beginPath();
                    ctx.moveTo(x - 2, y + (row === 0 ? 4 : -4));
                    if (row === 0) {
                        ctx.lineTo(x - 2, y + 20);
                        ctx.lineTo(x - 4, y + 25);
                    } else {
                        ctx.lineTo(x - 2, y - 20);
                        ctx.lineTo(x - 4, y - 25);
                    }
                    ctx.stroke();

                    // Tail 2
                    ctx.beginPath();
                    ctx.moveTo(x + 2, y + (row === 0 ? 4 : -4));
                    if (row === 0) {
                        ctx.lineTo(x + 2, y + 20);
                        ctx.lineTo(x + 4, y + 25);
                    } else {
                        ctx.lineTo(x + 2, y - 20);
                        ctx.lineTo(x + 4, y - 25);
                    }
                    ctx.stroke();
                }
            }

            // Membrane proteins
            // Ion channel
            ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
            ctx.beginPath();
            ctx.rect(centerX - 60, startY + 20, 15, membraneHeight - 40);
            ctx.fill();

            // Channel pore
            ctx.fillStyle = 'rgba(147, 197, 253, 0.6)';
            ctx.beginPath();
            ctx.rect(centerX - 55, startY + 30, 5, membraneHeight - 60);
            ctx.fill();

            // Receptor protein
            const receptorX = centerX + 20;
            ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
            ctx.beginPath();
            ctx.ellipse(receptorX, startY + membraneHeight/2, 12, 30, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ligand binding site
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(receptorX, startY + 15, 5, 0, Math.PI * 2);
            ctx.fill();

            // Transport protein
            ctx.fillStyle = 'rgba(251, 146, 60, 0.8)';
            ctx.beginPath();
            ctx.ellipse(centerX + 70, startY + membraneHeight/2, 10, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cholesterol molecules
            for (let c = 0; c < 6; c++) {
                const cholX = startX + 30 + c * 35;
                const cholY = startY + membraneHeight/2 + (c % 2 === 0 ? 8 : -8);

                ctx.fillStyle = 'rgba(234, 179, 8, 0.9)';
                ctx.beginPath();
                ctx.ellipse(cholX, cholY, 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glycoproteins/glycolipids
            for (let g = 0; g < 4; g++) {
                const glycoX = startX + 40 + g * 50;
                const glycoY = startY + 10;

                // Sugar chains
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(glycoX, glycoY + 25);
                ctx.lineTo(glycoX - 5, glycoY + 15);
                ctx.lineTo(glycoX - 3, glycoY + 5);
                ctx.stroke();

                // Sugar units
                ctx.fillStyle = '#ec4899';
                ctx.beginPath();
                ctx.arc(glycoX - 3, glycoY + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(glycoX - 5, glycoY + 15, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Cytoskeleton attachments
            ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 5; i++) {
                const cytoX = startX + 20 + i * 45;
                ctx.beginPath();
                ctx.moveTo(cytoX, startY + membraneHeight - 10);
                ctx.lineTo(cytoX - 10, startY + membraneHeight + 20);
                ctx.lineTo(cytoX + 10, startY + membraneHeight + 25);
                ctx.stroke();
            }
        }

        // Level 10: Protein complexes
        function drawProteinComplexes(ctx, centerX, centerY) {
            // Photosystem II complex
            const ps2X = centerX - 80;
            const ps2Y = centerY;

            // Core complex
            ctx.fillStyle = 'rgba(220, 38, 38, 0.7)';
            ctx.beginPath();
            ctx.ellipse(ps2X, ps2Y, 30, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // D1 and D2 proteins
            ctx.fillStyle = 'rgba(185, 28, 28, 0.9)';
            ctx.beginPath();
            ctx.rect(ps2X - 15, ps2Y - 20, 10, 40);
            ctx.fill();
            ctx.beginPath();
            ctx.rect(ps2X + 5, ps2Y - 20, 10, 40);
            ctx.fill();

            // Chlorophyll special pair (P680)
            ctx.fillStyle = '#10b981';
            ctx.beginPath();
            ctx.arc(ps2X - 5, ps2Y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ps2X + 5, ps2Y, 4, 0, Math.PI * 2);
            ctx.fill();

            // Antenna complex
            for (let a = 0; a < 8; a++) {
                const angle = (a / 8) * Math.PI * 2;
                const ax = ps2X + Math.cos(angle) * 40;
                const ay = ps2Y + Math.sin(angle) * 35;

                ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
                ctx.beginPath();
                ctx.arc(ax, ay, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // ATP synthase complex
            const atpX = centerX + 80;
            const atpY = centerY;

            // F0 portion (membrane embedded)
            ctx.fillStyle = 'rgba(251, 146, 60, 0.8)';
            ctx.beginPath();
            ctx.ellipse(atpX, atpY + 20, 20, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Stalk
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(atpX, atpY + 10);
            ctx.lineTo(atpX, atpY - 10);
            ctx.stroke();

            // F1 portion (catalytic head)
            ctx.fillStyle = 'rgba(251, 146, 60, 0.9)';

            // α and β subunits
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const subX = atpX + Math.cos(angle) * 15;
                const subY = atpY - 20 + Math.sin(angle) * 15;

                ctx.fillStyle = i % 2 === 0 ? 'rgba(251, 146, 60, 0.9)' : 'rgba(254, 215, 170, 0.9)';
                ctx.beginPath();
                ctx.arc(subX, subY, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // γ subunit (central stalk)
            ctx.fillStyle = '#ea580c';
            ctx.beginPath();
            ctx.arc(atpX, atpY - 20, 5, 0, Math.PI * 2);
            ctx.fill();

            // Rubisco complex
            const rubiscoX = centerX;
            const rubiscoY = centerY - 60;

            // Large subunits (8)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const lx = rubiscoX + Math.cos(angle) * 20;
                const ly = rubiscoY + Math.sin(angle) * 20;

                ctx.fillStyle = 'rgba(99, 102, 241, 0.8)';
                ctx.beginPath();
                ctx.arc(lx, ly, 7, 0, Math.PI * 2);
                ctx.fill();
            }

            // Small subunits (8)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.PI / 8;
                const sx = rubiscoX + Math.cos(angle) * 12;
                const sy = rubiscoY + Math.sin(angle) * 12;

                ctx.fillStyle = 'rgba(165, 180, 252, 0.9)';
                ctx.beginPath();
                ctx.arc(sx, sy, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Active sites
            ctx.fillStyle = '#fbbf24';
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const ax = rubiscoX + Math.cos(angle) * 8;
                const ay = rubiscoY + Math.sin(angle) * 8;
                ctx.beginPath();
                ctx.arc(ax, ay, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Level 11: Molecular machinery
        function drawMolecularMachinery(ctx, centerX, centerY) {
            // DNA polymerase at work
            const polyX = centerX - 50;
            const polyY = centerY;

            // DNA template strand
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(polyX - 80, polyY);
            for (let i = 0; i < 160; i++) {
                const x = polyX - 80 + i;
                const y = polyY + Math.sin(i * 0.1) * 10;
                ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Complementary strand
            ctx.strokeStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.moveTo(polyX - 80, polyY);
            for (let i = 0; i < 80; i++) {
                const x = polyX - 80 + i;
                const y = polyY - Math.sin(i * 0.1) * 10;
                ctx.lineTo(x, y);
            }
            ctx.stroke();

            // DNA polymerase enzyme
            const gradient = ctx.createRadialGradient(polyX, polyY, 0, polyX, polyY, 25);
            gradient.addColorStop(0, 'rgba(239, 68, 68, 0.9)');
            gradient.addColorStop(0.5, 'rgba(239, 68, 68, 0.7)');
            gradient.addColorStop(1, 'rgba(239, 68, 68, 0.4)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(polyX, polyY, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();

            // Active site
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(polyX, polyY, 5, 0, Math.PI * 2);
            ctx.fill();

            // Incoming nucleotides
            for (let n = 0; n < 4; n++) {
                const nx = polyX + 30 + n * 15;
                const ny = polyY - 30 + n * 5;

                const colors = ['#10b981', '#f59e0b', '#ef4444', '#3b82f6'];
                ctx.fillStyle = colors[n];
                ctx.beginPath();
                ctx.arc(nx, ny, 4, 0, Math.PI * 2);
                ctx.fill();

                // Triphosphate groups
                for (let p = 0; p < 3; p++) {
                    ctx.fillStyle = '#fde047';
                    ctx.beginPath();
                    ctx.arc(nx + 5 + p * 3, ny, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Ribosome translating mRNA
            const riboX = centerX + 60;
            const riboY = centerY - 30;

            // Large subunit
            ctx.fillStyle = 'rgba(168, 85, 247, 0.8)';
            ctx.beginPath();
            ctx.ellipse(riboX, riboY - 10, 30, 20, 0, 0, Math.PI * 2);
            ctx.fill();

            // Small subunit
            ctx.fillStyle = 'rgba(196, 181, 253, 0.8)';
            ctx.beginPath();
            ctx.ellipse(riboX, riboY + 10, 25, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // mRNA strand
            ctx.strokeStyle = '#ec4899';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(riboX - 60, riboY);
            ctx.quadraticCurveTo(riboX, riboY + 5, riboX + 60, riboY);
            ctx.stroke();

            // tRNA molecules
            const tRNAs = [
                { x: riboX - 10, color: '#10b981' },
                { x: riboX, color: '#f59e0b' },
                { x: riboX + 10, color: '#3b82f6' }
            ];

            tRNAs.forEach(tRNA => {
                // tRNA structure
                ctx.strokeStyle = tRNA.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(tRNA.x, riboY - 5);
                ctx.lineTo(tRNA.x - 5, riboY - 15);
                ctx.lineTo(tRNA.x, riboY - 20);
                ctx.lineTo(tRNA.x + 5, riboY - 15);
                ctx.lineTo(tRNA.x, riboY - 5);
                ctx.stroke();

                // Amino acid
                ctx.fillStyle = tRNA.color;
                ctx.beginPath();
                ctx.arc(tRNA.x, riboY - 25, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Growing protein chain
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(riboX - 30, riboY);
            for (let i = 0; i < 10; i++) {
                const px = riboX - 30 - i * 5;
                const py = riboY + Math.sin(i * 0.8) * 8;
                ctx.lineTo(px, py);

                // Amino acids in chain
                if (i % 2 === 0) {
                    ctx.fillStyle = '#6366f1';
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.stroke();
        }

        // Level 12: Amino acid chains
        function drawAminoAcidChains(ctx, centerX, centerY) {
            // Detailed protein structure

            // Primary structure - amino acid sequence
            const startX = centerX - 100;
            const startY = centerY - 50;

            const aminoAcids = [
                { name: 'Met', color: '#10b981' },
                { name: 'Ala', color: '#f59e0b' },
                { name: 'Gly', color: '#ef4444' },
                { name: 'Ser', color: '#3b82f6' },
                { name: 'Thr', color: '#8b5cf6' },
                { name: 'Val', color: '#ec4899' },
                { name: 'Leu', color: '#10b981' },
                { name: 'Ile', color: '#f59e0b' }
            ];

            // Draw peptide backbone
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY);

            aminoAcids.forEach((aa, i) => {
                const x = startX + i * 25;
                const y = startY;

                // Peptide bond
                if (i > 0) {
                    ctx.lineTo(x, y);
                }

                // Alpha carbon
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Side chain (R group)
                ctx.strokeStyle = aa.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y - 15);
                ctx.stroke();

                ctx.fillStyle = aa.color;
                ctx.beginPath();
                ctx.arc(x, y - 15, 5, 0, Math.PI * 2);
                ctx.fill();

                // Amino group (N-terminus)
                if (i === 0) {
                    ctx.fillStyle = '#3b82f6';
                    ctx.beginPath();
                    ctx.arc(x - 10, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillText('NH3+', x - 20, y - 10);
                }

                // Carboxyl group (C-terminus)
                if (i === aminoAcids.length - 1) {
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.arc(x + 10, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillText('COO-', x + 15, y - 10);
                }

                ctx.strokeStyle = '#6b7280';
            });
            ctx.stroke();

            // Secondary structure - alpha helix
            const helixX = centerX - 50;
            const helixY = centerY + 30;

            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 40; i++) {
                const angle = i * 0.4;
                const x = helixX + i * 2;
                const y = helixY + Math.sin(angle) * 15;
                const z = Math.cos(angle) * 15;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                // Hydrogen bonds
                if (i % 4 === 0 && i > 0) {
                    ctx.strokeStyle = 'rgba(147, 197, 253, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - 8, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 3;
                }
            }
            ctx.stroke();

            // Beta sheet
            const sheetX = centerX + 30;
            const sheetY = centerY + 30;

            // Draw beta strands
            for (let strand = 0; strand < 3; strand++) {
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.beginPath();

                for (let i = 0; i < 30; i++) {
                    const x = sheetX + i * 2;
                    const y = sheetY + strand * 15 + (i % 2) * 3;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Hydrogen bonds between strands
                if (strand < 2) {
                    ctx.strokeStyle = 'rgba(147, 197, 253, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    for (let h = 0; h < 5; h++) {
                        ctx.beginPath();
                        ctx.moveTo(sheetX + h * 12, sheetY + strand * 15);
                        ctx.lineTo(sheetX + h * 12, sheetY + (strand + 1) * 15);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }
            }

            // Disulfide bonds
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 70, centerY);
            ctx.quadraticCurveTo(centerX - 50, centerY - 20, centerX - 30, centerY);
            ctx.stroke();

            // Cysteine residues
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(centerX - 70, centerY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX - 30, centerY, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Level 13: Atomic structure
        function drawAtomicStructure(ctx, centerX, centerY) {
            // Glucose molecule C6H12O6
            const atoms = [
                // Carbon atoms (hexagon)
                { x: centerX - 30, y: centerY - 20, element: 'C' },
                { x: centerX + 30, y: centerY - 20, element: 'C' },
                { x: centerX + 50, y: centerY + 20, element: 'C' },
                { x: centerX + 30, y: centerY + 60, element: 'C' },
                { x: centerX - 30, y: centerY + 60, element: 'C' },
                { x: centerX - 50, y: centerY + 20, element: 'C' },

                // Oxygen atoms
                { x: centerX - 30, y: centerY - 50, element: 'O' },
                { x: centerX + 30, y: centerY - 50, element: 'O' },
                { x: centerX + 80, y: centerY + 20, element: 'O' },
                { x: centerX + 30, y: centerY + 90, element: 'O' },
                { x: centerX - 30, y: centerY + 90, element: 'O' },
                { x: centerX - 80, y: centerY + 20, element: 'O' },

                // Hydrogen atoms
                { x: centerX - 45, y: centerY - 35, element: 'H' },
                { x: centerX - 15, y: centerY - 35, element: 'H' },
                { x: centerX + 15, y: centerY - 35, element: 'H' },
                { x: centerX + 45, y: centerY - 35, element: 'H' },
                { x: centerX + 65, y: centerY + 5, element: 'H' },
                { x: centerX + 65, y: centerY + 35, element: 'H' },
                { x: centerX + 45, y: centerY + 75, element: 'H' },
                { x: centerX + 15, y: centerY + 75, element: 'H' },
                { x: centerX - 15, y: centerY + 75, element: 'H' },
                { x: centerX - 45, y: centerY + 75, element: 'H' },
                { x: centerX - 65, y: centerY + 35, element: 'H' },
                { x: centerX - 65, y: centerY + 5, element: 'H' }
            ];

            // Draw covalent bonds
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 2;

            // C-C bonds (ring)
            const carbonBonds = [
                [0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]
            ];

            carbonBonds.forEach(bond => {
                const atom1 = atoms[bond[0]];
                const atom2 = atoms[bond[1]];
                ctx.beginPath();
                ctx.moveTo(atom1.x, atom1.y);
                ctx.lineTo(atom2.x, atom2.y);
                ctx.stroke();
            });

            // C-O bonds
            const oxygenBonds = [
                [0, 6], [1, 7], [2, 8], [3, 9], [4, 10], [5, 11]
            ];

            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            oxygenBonds.forEach(bond => {
                const atom1 = atoms[bond[0]];
                const atom2 = atoms[bond[1]];
                ctx.beginPath();
                ctx.moveTo(atom1.x, atom1.y);
                ctx.lineTo(atom2.x, atom2.y);
                ctx.stroke();
            });

            // C-H and O-H bonds
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;

            // Connect hydrogens
            const hydrogenBonds = [
                [6, 12], [6, 13], [7, 14], [7, 15],
                [8, 16], [8, 17], [9, 18], [9, 19],
                [10, 20], [10, 21], [11, 22], [11, 23]
            ];

            hydrogenBonds.forEach(bond => {
                const atom1 = atoms[bond[0]];
                const atom2 = atoms[bond[1]];
                ctx.beginPath();
                ctx.moveTo(atom1.x, atom1.y);
                ctx.lineTo(atom2.x, atom2.y);
                ctx.stroke();
            });

            // Draw atoms
            atoms.forEach(atom => {
                let color, size;
                switch(atom.element) {
                    case 'C':
                        color = '#1f2937';
                        size = 8;
                        break;
                    case 'O':
                        color = '#ef4444';
                        size = 7;
                        break;
                    case 'H':
                        color = '#e5e7eb';
                        size = 4;
                        break;
                }

                // Atom sphere
                const gradient = ctx.createRadialGradient(
                    atom.x - size/3, atom.y - size/3, 0,
                    atom.x, atom.y, size
                );
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.7, color);
                gradient.addColorStop(1, 'rgba(0,0,0,0.2)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(atom.x, atom.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Atom label
                ctx.fillStyle = atom.element === 'C' ? '#ffffff' : '#ffffff';
                ctx.font = 'bold 8px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(atom.element, atom.x, atom.y);
            });

            // Water molecule for scale
            const waterX = centerX - 100;
            const waterY = centerY - 60;

            // Oxygen
            const oGradient = ctx.createRadialGradient(
                waterX - 3, waterY - 3, 0,
                waterX, waterY, 10
            );
            oGradient.addColorStop(0, '#ef4444');
            oGradient.addColorStop(1, 'rgba(239, 68, 68, 0.5)');
            ctx.fillStyle = oGradient;
            ctx.beginPath();
            ctx.arc(waterX, waterY, 10, 0, Math.PI * 2);
            ctx.fill();

            // Hydrogens
            const h1X = waterX - 15;
            const h1Y = waterY + 12;
            const h2X = waterX + 15;
            const h2Y = waterY + 12;

            ctx.fillStyle = '#e5e7eb';
            ctx.beginPath();
            ctx.arc(h1X, h1Y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(h2X, h2Y, 5, 0, Math.PI * 2);
            ctx.fill();

            // Bonds
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(waterX, waterY);
            ctx.lineTo(h1X, h1Y);
            ctx.moveTo(waterX, waterY);
            ctx.lineTo(h2X, h2Y);
            ctx.stroke();

            // Bond angle annotation
            ctx.strokeStyle = 'rgba(147, 197, 253, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.arc(waterX, waterY, 20, 0.7, 2.44, false);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#64748b';
            ctx.font = '10px sans-serif';
            ctx.fillText('104.5°', waterX, waterY + 30);
        }

        // Level 14: Electron orbitals
        function drawElectronOrbitals(ctx, centerX, centerY) {
            // Carbon atom with electron orbitals

            // Nucleus
            const nucleusSize = 15;
            const nucleusGradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, nucleusSize
            );
            nucleusGradient.addColorStop(0, '#dc2626');
            nucleusGradient.addColorStop(0.7, '#b91c1c');
            nucleusGradient.addColorStop(1, '#991b1b');

            ctx.fillStyle = nucleusGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, nucleusSize, 0, Math.PI * 2);
            ctx.fill();

            // Protons and neutrons representation
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('6p⁺', centerX, centerY - 3);
            ctx.fillText('6n', centerX, centerY + 5);

            // 1s orbital (spherical)
            const s1Gradient = ctx.createRadialGradient(
                centerX, centerY, nucleusSize,
                centerX, centerY, 40
            );
            s1Gradient.addColorStop(0, 'rgba(59, 130, 246, 0.6)');
            s1Gradient.addColorStop(0.5, 'rgba(59, 130, 246, 0.3)');
            s1Gradient.addColorStop(1, 'rgba(59, 130, 246, 0.05)');

            ctx.fillStyle = s1Gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
            ctx.fill();

            // 2s orbital (larger sphere)
            const s2Gradient = ctx.createRadialGradient(
                centerX, centerY, 40,
                centerX, centerY, 70
            );
            s2Gradient.addColorStop(0, 'rgba(34, 197, 94, 0.4)');
            s2Gradient.addColorStop(0.5, 'rgba(34, 197, 94, 0.2)');
            s2Gradient.addColorStop(1, 'rgba(34, 197, 94, 0.05)');

            ctx.fillStyle = s2Gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 70, 0, Math.PI * 2);
            ctx.fill();

            // 2p orbitals (dumbbell shaped)
            // px orbital
            ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
            ctx.beginPath();
            ctx.ellipse(centerX - 50, centerY, 30, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + 50, centerY, 30, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // py orbital
            ctx.fillStyle = 'rgba(251, 146, 60, 0.3)';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY - 50, 15, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + 50, 15, 30, 0, 0, Math.PI * 2);
            ctx.fill();

            // Electron probability clouds (dots)
            for (let i = 0; i < 200; i++) {
                const radius = Math.random() * 80;
                const angle = Math.random() * Math.PI * 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                // Probability density decreases with distance
                const probability = Math.exp(-radius / 30);

                if (Math.random() < probability) {
                    ctx.fillStyle = `rgba(59, 130, 246, ${probability * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Hydrogen atom for comparison
            const hX = centerX + 120;
            const hY = centerY - 50;

            // Hydrogen nucleus (single proton)
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(hX, hY, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 8px sans-serif';
            ctx.fillText('p⁺', hX, hY);

            // 1s orbital for hydrogen
            const h1sGradient = ctx.createRadialGradient(hX, hY, 0, hX, hY, 30);
            h1sGradient.addColorStop(0, 'rgba(147, 197, 253, 0.6)');
            h1sGradient.addColorStop(0.5, 'rgba(147, 197, 253, 0.3)');
            h1sGradient.addColorStop(1, 'rgba(147, 197, 253, 0.05)');

            ctx.fillStyle = h1sGradient;
            ctx.beginPath();
            ctx.arc(hX, hY, 30, 0, Math.PI * 2);
            ctx.fill();

            // Orbital energy levels diagram
            const diagramX = centerX - 120;
            const diagramY = centerY + 50;

            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 1;

            // Energy levels
            const levels = [
                { y: 0, label: '2p', electrons: 2 },
                { y: 20, label: '2s', electrons: 2 },
                { y: 60, label: '1s', electrons: 2 }
            ];

            levels.forEach(level => {
                // Energy level line
                ctx.beginPath();
                ctx.moveTo(diagramX - 20, diagramY + level.y);
                ctx.lineTo(diagramX + 20, diagramY + level.y);
                ctx.stroke();

                // Label
                ctx.fillStyle = '#6b7280';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(level.label, diagramX - 25, diagramY + level.y + 3);

                // Electrons (up and down arrows)
                for (let e = 0; e < level.electrons; e++) {
                    const ex = diagramX - 10 + e * 20;
                    const ey = diagramY + level.y;

                    ctx.strokeStyle = e % 2 === 0 ? '#3b82f6' : '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(ex, ey - 5);
                    ctx.lineTo(ex, ey - 10);
                    // Arrow head
                    ctx.moveTo(ex - 2, ey - 8);
                    ctx.lineTo(ex, ey - 10);
                    ctx.lineTo(ex + 2, ey - 8);
                    ctx.stroke();
                }
            });
        }

        // Level 15: Molecular dynamics
        function drawMolecularDynamics(ctx, centerX, centerY) {
            // Animated molecular system with forces and movements
            const time = Date.now() * 0.001;

            // Water molecules in motion
            const molecules = [];
            for (let i = 0; i < 12; i++) {
                const baseX = centerX + (i % 4 - 1.5) * 60;
                const baseY = centerY + (Math.floor(i / 4) - 1) * 60;

                // Add vibration and rotation
                const vibration = Math.sin(time * 5 + i) * 3;
                const rotation = time * 0.5 + i * 0.5;

                molecules.push({
                    x: baseX + Math.sin(time + i) * 20,
                    y: baseY + Math.cos(time + i * 0.7) * 20,
                    rotation: rotation,
                    vibration: vibration
                });
            }

            // Draw intermolecular forces (hydrogen bonds)
            ctx.strokeStyle = 'rgba(147, 197, 253, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);

            molecules.forEach((mol1, i) => {
                molecules.forEach((mol2, j) => {
                    if (i < j) {
                        const dist = Math.sqrt(
                            Math.pow(mol2.x - mol1.x, 2) +
                            Math.pow(mol2.y - mol1.y, 2)
                        );

                        if (dist < 80 && dist > 30) {
                            const strength = 1 - (dist - 30) / 50;
                            ctx.strokeStyle = `rgba(147, 197, 253, ${strength * 0.4})`;
                            ctx.beginPath();
                            ctx.moveTo(mol1.x, mol1.y);
                            ctx.lineTo(mol2.x, mol2.y);
                            ctx.stroke();
                        }
                    }
                });
            });
            ctx.setLineDash([]);

            // Draw water molecules
            molecules.forEach(mol => {
                ctx.save();
                ctx.translate(mol.x, mol.y);
                ctx.rotate(mol.rotation);

                // Oxygen atom
                const oSize = 8 + mol.vibration * 0.3;
                const oGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, oSize);
                oGradient.addColorStop(0, 'rgba(239, 68, 68, 0.9)');
                oGradient.addColorStop(1, 'rgba(239, 68, 68, 0.4)');

                ctx.fillStyle = oGradient;
                ctx.beginPath();
                ctx.arc(0, 0, oSize, 0, Math.PI * 2);
                ctx.fill();

                // Hydrogen atoms with bond stretching
                const bondLength = 15 + mol.vibration * 0.5;
                const bondAngle = Math.PI / 3;

                const h1X = Math.cos(-bondAngle) * bondLength;
                const h1Y = Math.sin(-bondAngle) * bondLength;
                const h2X = Math.cos(bondAngle) * bondLength;
                const h2Y = Math.sin(bondAngle) * bondLength;

                // H1
                ctx.fillStyle = 'rgba(229, 231, 235, 0.9)';
                ctx.beginPath();
                ctx.arc(h1X, h1Y, 4, 0, Math.PI * 2);
                ctx.fill();

                // H2
                ctx.beginPath();
                ctx.arc(h2X, h2Y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Covalent bonds with vibration
                ctx.strokeStyle = 'rgba(156, 163, 175, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(h1X, h1Y);
                ctx.moveTo(0, 0);
                ctx.lineTo(h2X, h2Y);
                ctx.stroke();

                ctx.restore();
            });

            // Kinetic energy visualization
            const kineticX = centerX - 100;
            const kineticY = centerY - 80;

            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Kinetic Energy', kineticX, kineticY);

            // Energy bar
            const energy = (Math.sin(time * 2) + 1) * 0.5;
            ctx.fillStyle = `hsl(${energy * 60}, 70%, 50%)`;
            ctx.fillRect(kineticX, kineticY + 5, energy * 80, 10);

            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 1;
            ctx.strokeRect(kineticX, kineticY + 5, 80, 10);

            // Potential energy visualization
            const potentialY = kineticY + 30;
            ctx.fillStyle = '#6b7280';
            ctx.fillText('Potential Energy', kineticX, potentialY);

            const potential = (Math.cos(time * 2) + 1) * 0.5;
            ctx.fillStyle = `hsl(${240 - potential * 60}, 70%, 50%)`;
            ctx.fillRect(kineticX, potentialY + 5, potential * 80, 10);
            ctx.strokeRect(kineticX, potentialY + 5, 80, 10);

            // Temperature indicator
            const temp = 298 + Math.sin(time) * 20;
            ctx.fillStyle = '#6b7280';
            ctx.fillText(`T = ${temp.toFixed(1)} K`, kineticX, potentialY + 35);

            // Reaction coordinate (chemical reaction in progress)
            const reactionX = centerX + 50;
            const reactionY = centerY + 70;

            // Reactant
            ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
            ctx.beginPath();
            ctx.arc(reactionX - 40, reactionY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Transition state
            const transitionProgress = (Math.sin(time * 3) + 1) * 0.5;
            const tsX = reactionX - 40 + transitionProgress * 80;
            const tsY = reactionY - transitionProgress * (1 - transitionProgress) * 40;

            ctx.fillStyle = 'rgba(251, 146, 60, 0.8)';
            ctx.beginPath();
            ctx.arc(tsX, tsY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Product
            ctx.fillStyle = 'rgba(99, 102, 241, 0.8)';
            ctx.beginPath();
            ctx.arc(reactionX + 40, reactionY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Reaction pathway
            ctx.strokeStyle = 'rgba(107, 114, 128, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(reactionX - 40, reactionY);
            ctx.quadraticCurveTo(reactionX, reactionY - 20, reactionX + 40, reactionY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Force vectors
            molecules.forEach((mol, i) => {
                if (i % 3 === 0) {
                    const forceAngle = time * 2 + i;
                    const forceMag = 15;

                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(mol.x, mol.y);
                    ctx.lineTo(
                        mol.x + Math.cos(forceAngle) * forceMag,
                        mol.y + Math.sin(forceAngle) * forceMag
                    );
                    ctx.stroke();

                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(
                        mol.x + Math.cos(forceAngle) * forceMag,
                        mol.y + Math.sin(forceAngle) * forceMag
                    );
                    ctx.lineTo(
                        mol.x + Math.cos(forceAngle - 0.3) * (forceMag - 5),
                        mol.y + Math.sin(forceAngle - 0.3) * (forceMag - 5)
                    );
                    ctx.stroke();
                }
            });

            // Request animation frame for continuous animation
            animationFrameId = requestAnimationFrame(() => drawMolecularDynamics(ctx, centerX, centerY));
        }

        // Removed drawLODSystem - now using drawCellAtLOD instead
        function drawLODSystem_REMOVED(ctx, level) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            
            // Draw a golden poppy with varying detail levels
            if (level <= 2) {
                // Very low detail - basic flower shape
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 60, 0, Math.PI * 2);
                ctx.fill();
                
                // Stem
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.lineTo(centerX, centerY + 150);
                ctx.stroke();
                
            } else if (level <= 4) {
                // Low detail - distinct petals
                ctx.fillStyle = '#fbbf24';
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const petalX = centerX + Math.cos(angle) * 30;
                    const petalY = centerY - 20 + Math.sin(angle) * 30;
                    ctx.beginPath();
                    ctx.ellipse(petalX, petalY, 35, 25, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Center
                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Stem with basic curve
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.quadraticCurveTo(centerX - 10, centerY + 80, centerX - 5, centerY + 150);
                ctx.stroke();
                
            } else if (level <= 6) {
                // Medium detail - realistic petal shapes
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    const petalX = centerX + Math.cos(angle) * 35;
                    const petalY = centerY - 20 + Math.sin(angle) * 35;
                    
                    // Petal with gradient
                    const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 35);
                    gradient.addColorStop(0, '#fde68a');
                    gradient.addColorStop(0.7, '#fbbf24');
                    gradient.addColorStop(1, '#f59e0b');
                    ctx.fillStyle = gradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - 20);
                    ctx.quadraticCurveTo(
                        petalX + Math.cos(angle - 0.5) * 20, 
                        petalY + Math.sin(angle - 0.5) * 20,
                        petalX + Math.cos(angle) * 40, 
                        petalY + Math.sin(angle) * 40
                    );
                    ctx.quadraticCurveTo(
                        petalX + Math.cos(angle + 0.5) * 20, 
                        petalY + Math.sin(angle + 0.5) * 20,
                        centerX, centerY - 20
                    );
                    ctx.fill();
                }
                
                // Detailed center with texture
                ctx.fillStyle = '#ea580c';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 18, 0, Math.PI * 2);
                ctx.fill();
                
                // Add some texture dots
                for (let i = 0; i < 10; i++) {
                    const r = Math.random() * 12;
                    const a = Math.random() * Math.PI * 2;
                    ctx.fillStyle = '#7c2d12';
                    ctx.beginPath();
                    ctx.arc(centerX + Math.cos(a) * r, centerY - 20 + Math.sin(a) * r, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Stem with thorns
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.quadraticCurveTo(centerX - 15, centerY + 80, centerX - 5, centerY + 150);
                ctx.stroke();
                
                // Leaves
                ctx.fillStyle = '#16a34a';
                ctx.beginPath();
                ctx.ellipse(centerX - 20, centerY + 80, 15, 8, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (level <= 8) {
                // High detail - complex petal structure
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    const petalX = centerX + Math.cos(angle) * 35;
                    const petalY = centerY - 20 + Math.sin(angle) * 35;
                    
                    // Multi-layer gradient for silk-like appearance
                    const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 40);
                    gradient.addColorStop(0, '#fef3c7');
                    gradient.addColorStop(0.3, '#fde68a');
                    gradient.addColorStop(0.6, '#fbbf24');
                    gradient.addColorStop(0.9, '#f59e0b');
                    gradient.addColorStop(1, '#dc2626');
                    ctx.fillStyle = gradient;
                    
                    // Ruffled petal edges
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - 20);
                    for (let j = 0; j <= 20; j++) {
                        const t = j / 20;
                        const baseAngle = angle - 0.6 + t * 1.2;
                        const radius = 35 + Math.sin(j * 2) * 3;
                        const px = centerX + Math.cos(baseAngle) * radius;
                        const py = centerY - 20 + Math.sin(baseAngle) * radius;
                        if (j === 0) {
                            ctx.lineTo(px, py);
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Petal veins
                    ctx.strokeStyle = 'rgba(245, 158, 11, 0.3)';
                    ctx.lineWidth = 0.5;
                    for (let v = 0; v < 3; v++) {
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        const vAngle = angle + (v - 1) * 0.2;
                        ctx.quadraticCurveTo(
                            centerX + Math.cos(vAngle) * 20,
                            centerY - 20 + Math.sin(vAngle) * 20,
                            centerX + Math.cos(vAngle) * 40,
                            centerY - 20 + Math.sin(vAngle) * 40
                        );
                        ctx.stroke();
                    }
                }
                
                // Highly detailed center
                const centerGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 20);
                centerGradient.addColorStop(0, '#7c2d12');
                centerGradient.addColorStop(0.5, '#dc2626');
                centerGradient.addColorStop(1, '#ea580c');
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Pollen texture
                for (let i = 0; i < 30; i++) {
                    const r = Math.random() * 15;
                    const a = Math.random() * Math.PI * 2;
                    ctx.fillStyle = `rgba(124, 45, 18, ${Math.random() * 0.5 + 0.5})`;
                    ctx.beginPath();
                    ctx.arc(centerX + Math.cos(a) * r, centerY - 20 + Math.sin(a) * r, Math.random() * 2 + 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Detailed stem with natural curve
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.bezierCurveTo(
                    centerX - 10, centerY + 70,
                    centerX - 20, centerY + 100,
                    centerX - 8, centerY + 150
                );
                ctx.stroke();
                
                // Multiple leaves with veins
                const leaves = [
                    { x: centerX - 25, y: centerY + 75, angle: -0.4 },
                    { x: centerX - 15, y: centerY + 110, angle: -0.2 }
                ];
                
                leaves.forEach(leaf => {
                    ctx.fillStyle = '#16a34a';
                    ctx.save();
                    ctx.translate(leaf.x, leaf.y);
                    ctx.rotate(leaf.angle);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 18, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Leaf veins
                    ctx.strokeStyle = '#14532d';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.lineTo(15, 0);
                    ctx.stroke();
                    ctx.restore();
                });
                
            } else {
                // Ultra high detail - botanical illustration quality
                // Draw with maximum botanical accuracy
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    
                    // Each petal with unique characteristics
                    for (let layer = 0; layer < 3; layer++) {
                        const layerOffset = layer * 2;
                        const petalX = centerX + Math.cos(angle) * (35 - layerOffset);
                        const petalY = centerY - 20 + Math.sin(angle) * (35 - layerOffset);
                        
                        const gradient = ctx.createRadialGradient(petalX, petalY, 0, petalX, petalY, 45 - layerOffset);
                        gradient.addColorStop(0, `rgba(254, 243, 199, ${1 - layer * 0.2})`);
                        gradient.addColorStop(0.3, `rgba(253, 230, 138, ${1 - layer * 0.2})`);
                        gradient.addColorStop(0.5, `rgba(251, 191, 36, ${1 - layer * 0.2})`);
                        gradient.addColorStop(0.8, `rgba(245, 158, 11, ${1 - layer * 0.2})`);
                        gradient.addColorStop(1, `rgba(220, 38, 38, ${0.8 - layer * 0.2})`);
                        ctx.fillStyle = gradient;
                        
                        // Irregular petal shape
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        for (let j = 0; j <= 30; j++) {
                            const t = j / 30;
                            const baseAngle = angle - 0.7 + t * 1.4;
                            const irregularity = Math.sin(j * 3) * 2 + Math.sin(j * 7) * 1;
                            const radius = (38 - layerOffset) + irregularity + Math.random() * 1;
                            const px = centerX + Math.cos(baseAngle) * radius;
                            const py = centerY - 20 + Math.sin(baseAngle) * radius;
                            ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Fine petal veins
                    ctx.strokeStyle = 'rgba(220, 38, 38, 0.15)';
                    ctx.lineWidth = 0.3;
                    for (let v = 0; v < 7; v++) {
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        const vAngle = angle + (v - 3) * 0.15;
                        const controlX = centerX + Math.cos(vAngle) * 20;
                        const controlY = centerY - 20 + Math.sin(vAngle) * 20;
                        const endX = centerX + Math.cos(vAngle) * (38 + Math.random() * 5);
                        const endY = centerY - 20 + Math.sin(vAngle) * (38 + Math.random() * 5);
                        ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                        ctx.stroke();
                    }
                }
                
                // Ultra-detailed center with stamens
                const centerGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 22);
                centerGradient.addColorStop(0, '#451a03');
                centerGradient.addColorStop(0.3, '#7c2d12');
                centerGradient.addColorStop(0.6, '#dc2626');
                centerGradient.addColorStop(1, '#f97316');
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 22, 0, Math.PI * 2);
                ctx.fill();
                
                // Individual pollen grains and stamens
                for (let ring = 0; ring < 3; ring++) {
                    const count = 10 + ring * 8;
                    for (let i = 0; i < count; i++) {
                        const a = (i / count) * Math.PI * 2;
                        const r = 8 + ring * 5;
                        const x = centerX + Math.cos(a) * r;
                        const y = centerY - 20 + Math.sin(a) * r;
                        
                        // Stamen
                        ctx.strokeStyle = '#7c2d12';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - 20);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        
                        // Pollen
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(x, y, 1 + Math.random() * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Photorealistic stem with natural imperfections
                ctx.strokeStyle = '#16a34a';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 40);
                ctx.bezierCurveTo(
                    centerX - 12, centerY + 70,
                    centerX - 22, centerY + 100,
                    centerX - 10, centerY + 150
                );
                ctx.stroke();
                
                // Stem texture
                ctx.strokeStyle = '#14532d';
                ctx.lineWidth = 0.3;
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    const sy = centerY + 50 + i * 5;
                    const sx = centerX - 10 + Math.sin(sy * 0.1) * 10;
                    ctx.moveTo(sx - 2, sy);
                    ctx.lineTo(sx + 2, sy);
                    ctx.stroke();
                }
                
                // Detailed compound leaves with serrated edges
                const leaves = [
                    { x: centerX - 28, y: centerY + 70, angle: -0.4, size: 1 },
                    { x: centerX - 18, y: centerY + 105, angle: -0.2, size: 0.8 },
                    { x: centerX - 5, y: centerY + 125, angle: 0.1, size: 0.6 }
                ];
                
                leaves.forEach(leaf => {
                    ctx.save();
                    ctx.translate(leaf.x, leaf.y);
                    ctx.rotate(leaf.angle);
                    ctx.scale(leaf.size, leaf.size);
                    
                    // Leaf with serrated edges
                    ctx.fillStyle = '#16a34a';
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    for (let i = 0; i <= 20; i++) {
                        const x = -20 + i * 2;
                        const y = Math.sin(i * 0.8) * 3 * Math.sin(x * 0.1 + 1.5);
                        ctx.lineTo(x, y + (i % 2 ? -2 : 2));
                    }
                    for (let i = 20; i >= 0; i--) {
                        const x = -20 + i * 2;
                        const y = Math.sin(i * 0.8) * 3 * Math.sin(x * 0.1 + 1.5);
                        ctx.lineTo(x, -y + (i % 2 ? 2 : -2));
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Leaf veins
                    ctx.strokeStyle = '#0f4a2a';
                    ctx.lineWidth = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(20, 0);
                    ctx.stroke();
                    
                    for (let v = -15; v <= 15; v += 5) {
                        ctx.beginPath();
                        ctx.moveTo(v, 0);
                        ctx.lineTo(v + 3, 4);
                        ctx.moveTo(v, 0);
                        ctx.lineTo(v + 3, -4);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
            }
        }

        function updateCompressionDisplay(level) {
            const display = document.getElementById('paramDisplay');
            const errorDisplay = document.getElementById('errorThreshold');
            if (!display) return;

            const compressionData = {
                1: {
                    params: 'color, radius',
                    bits: '~8 bits',
                    desc: 'Shape = circle(1), Color(4), Size(3)',
                    error: 'σ² ≈ 0.08',
                    threshold: 'Petal structure approximated as random variation',
                    influences: 'Next level adds: Individual petal geometry (high structural info)'
                },
                2: {
                    params: 'petals[6], colors[2]',
                    bits: '~16 bits',
                    desc: 'Petal count(3), Petal shape(4), Colors(9)',
                    error: 'σ² ≈ 0.03',
                    threshold: 'Surface texture approximated as noise',
                    influences: 'Next level adds: Gradient patterns (mostly aesthetic)'
                },
                3: {
                    params: 'texture_gradient[3], veins[n]',
                    bits: '~32 bits',
                    desc: 'Gradients(12), Vein patterns(20)',
                    error: 'σ² ≈ 0.09',
                    threshold: 'Cell boundaries approximated as uniform texture',
                    influences: 'Next level adds: Thousands of individual cells (huge jump)'
                },
                4: {
                    params: 'cell_grid[x,y], cell_type',
                    bits: '~128 bits',
                    desc: 'Cell positions(64), Cell shapes(64)',
                    error: 'σ² ≈ 0.02',
                    threshold: 'Tissue microstructure approximated as homogeneous',
                    influences: 'Next level adds: Layer differentiation (mostly structural)'
                },
                5: {
                    params: 'tissue_layers[4], density_map',
                    bits: '~256 bits',
                    desc: 'Layer types(32), Cell densities(224)',
                    error: 'σ² ≈ 0.07',
                    threshold: 'Organelle distribution approximated as statistical',
                    influences: 'Next level adds: Dozens of organelles per cell (complex dynamics)'
                },
                6: {
                    params: 'organelles[n], positions[3D]',
                    bits: '~512 bits',
                    desc: 'Organelle types(128), Positions(384)',
                    error: 'σ² ≈ 0.04',
                    threshold: 'Internal structures approximated as simple shapes',
                    influences: 'Next level adds: Detailed architecture (moderate complexity)'
                },
                7: {
                    params: 'membrane_proteins, internal_struct',
                    bits: '~1KB',
                    desc: 'Protein positions(512), Structures(512)',
                    error: 'σ² ≈ 0.06',
                    threshold: 'Chloroplast internals approximated as uniform',
                    influences: 'Next level adds: Complex thylakoid networks'
                },
                8: {
                    params: 'thylakoid_stacks, grana_network',
                    bits: '~2KB',
                    desc: 'Stack geometry(1024), Connections(1024)',
                    error: 'σ² ≈ 0.10',
                    threshold: 'Membrane proteins approximated as point masses',
                    influences: 'Next level adds: Lipid dynamics (highly variable)'
                },
                9: {
                    params: 'lipid_bilayer, protein_complex',
                    bits: '~4KB',
                    desc: 'Lipid arrangement(2048), Proteins(2048)',
                    error: 'σ² ≈ 0.05',
                    threshold: 'Protein subunits approximated as rigid bodies',
                    influences: 'Next level adds: Subunit flexibility (moderate dynamics)'
                },
                10: {
                    params: 'subunit_assembly, active_sites',
                    bits: '~8KB',
                    desc: 'Subunit positions(4096), Binding sites(4096)',
                    error: 'σ² ≈ 0.09',
                    threshold: 'Molecular machinery approximated as static',
                    influences: 'Next level adds: Conformational changes (high dynamics)'
                },
                11: {
                    params: 'polymer_chains, catalytic_state',
                    bits: '~16KB',
                    desc: 'Chain conformations(8192), States(8192)',
                    error: 'σ² ≈ 0.03',
                    threshold: 'Amino acid side chains approximated as average',
                    influences: 'Next level adds: Residue detail (mostly structural)'
                },
                12: {
                    params: 'residue_sequence, fold_pattern',
                    bits: '~32KB',
                    desc: 'Amino acids(16384), Secondary structure(16384)',
                    error: 'σ² ≈ 0.08',
                    threshold: 'Bond angles/lengths approximated as ideal',
                    influences: 'Next level adds: All atomic positions (massive increase)'
                },
                13: {
                    params: 'atom_positions, bond_network',
                    bits: '~64KB',
                    desc: 'XYZ coordinates(32768), Connectivity(32768)',
                    error: 'σ² ≈ 0.06',
                    threshold: 'Electron density approximated as spherical',
                    influences: 'Next level adds: Quantum orbital shapes'
                },
                14: {
                    params: 'wavefunctions, orbital_occupancy',
                    bits: '~128KB',
                    desc: 'Quantum states(65536), Electron density(65536)',
                    error: 'σ² ≈ 0.10',
                    threshold: 'Thermal motion approximated as harmonic',
                    influences: 'Next level adds: Full molecular dynamics (extreme dynamics)'
                },
                15: {
                    params: 'force_field, trajectories',
                    bits: '~256KB',
                    desc: 'Force vectors(131072), Time evolution(131072)',
                    error: 'σ² ≈ 0',
                    threshold: 'Full representation - no approximation',
                    influences: 'Complete molecular dynamics simulation'
                }
            };

            const data = compressionData[level];
            display.innerHTML = `
                <div style="margin-bottom: 5px;"><strong>Parameters:</strong> ${data.params}</div>
                <div style="margin-bottom: 5px;"><strong>Compressed to:</strong> ${data.bits}</div>
                <div style="font-size: 11px; opacity: 0.8;">${data.desc}</div>
            `;

            if (errorDisplay) {
                errorDisplay.innerHTML = `
                    <div style="margin-bottom: 5px; color: #f59e0b;"><strong>Variance from next level:</strong> ${data.error}</div>
                    <div style="font-size: 11px; opacity: 0.9; color: #ef4444;">${data.threshold}</div>
                    <div style="font-size: 11px; opacity: 0.7; margin-top: 3px; color: #10b981;">${data.influences}</div>
                `;
            }
        }

        function updateLOD(value) {
            const level = parseInt(value);
            document.getElementById('lodValue').textContent = level;

            const canvas = document.getElementById('lodCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                drawFlowerAtLOD(ctx, level);
                updateCompressionDisplay(level);
            }

            // Update info based on cell detail level
            let title, description, params, viewLevel;
            if (level <= 3) {
                title = 'Cell Overview';
                description = 'Basic cell shape and type identification.';
                params = 100 + (level - 1) * 300;
                viewLevel = 'Whole Cell';
            } else if (level <= 7) {
                title = 'Organelle Detail';
                description = 'Detailed organelle structure and distribution.';
                params = 1000 + (level - 4) * 2000;
                viewLevel = 'Organelle Level';
            } else {
                title = 'Molecular View';
                description = 'Molecular interactions, proteins, and DNA structure.';
                params = 10000 + (level - 8) * 20000;
                viewLevel = 'Molecular Level';
            }

            const titleEl = document.getElementById('lodTitle');
            const descEl = document.getElementById('lodDescription');
            const paramEl = document.getElementById('paramCount');
            const viewEl = document.getElementById('viewLevel');

            if (titleEl) titleEl.textContent = title;
            if (descEl) descEl.textContent = description;
            if (paramEl) paramEl.textContent = params.toLocaleString();
            if (viewEl) viewEl.textContent = viewLevel;
        }

        function simulateProblem(complexity) {
            const slider = document.getElementById('lodSlider');
            if (!slider) return;
            const targetValue = complexity === 'simple' ? 2 : 9;
            
            let current = parseInt(slider.value);
            const step = current < targetValue ? 1 : -1;
            
            function adjustDetail() {
                if (current !== targetValue) {
                    current += step;
                    slider.value = current;
                    updateLOD(current);
                    setTimeout(adjustDetail, 200);
                }
            }
            adjustDetail();
        }

        function autoAdapt() {
            const sequence = [2, 4, 6, 8, 10, 8, 5, 3, 7, 9, 4];
            let index = 0;
            
            function nextAdaptation() {
                if (index < sequence.length) {
                    const slider = document.getElementById('lodSlider');
                    if (slider) {
                        slider.value = sequence[index];
                        updateLOD(sequence[index]);
                    }
                    index++;
                    setTimeout(nextAdaptation, 800);
                }
            }
            nextAdaptation();
        }

        function initCellVisualization() {
            const canvas = document.getElementById('cellCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            drawCell(ctx, 'cell');
        }

        function drawCell(ctx, zoomLevel) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            
            if (zoomLevel === 'molecular') {
                // Draw molecular level - proteins, DNA strands, etc.
                // DNA double helix
                for (let i = 0; i < 100; i++) {
                    const t = i / 100;
                    const x1 = centerX - 100 + t * 200;
                    const y1 = centerY + Math.sin(t * Math.PI * 4) * 50;
                    const y2 = centerY + Math.sin(t * Math.PI * 4 + Math.PI) * 50;
                    
                    // Base pairs
                    ctx.strokeStyle = `hsla(${200 + i * 1.5}, 70%, 60%, 0.8)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1, y2);
                    ctx.stroke();
                    
                    // Sugar-phosphate backbone
                    ctx.fillStyle = '#667eea';
                    ctx.beginPath();
                    ctx.arc(x1, y1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#f093fb';
                    ctx.beginPath();
                    ctx.arc(x1, y2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Proteins
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    
                    // Alpha helices
                    ctx.strokeStyle = `hsla(${Math.random() * 60 + 30}, 70%, 60%, 0.6)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let j = 0; j < 10; j++) {
                        const angle = j * 0.6;
                        const px = x + Math.cos(angle) * 10;
                        const py = y + j * 3 + Math.sin(angle) * 5;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // ATP molecules
                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    ctx.fillStyle = '#667eea';
                    
                    // Adenosine
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Phosphate groups
                    for (let p = 0; p < 3; p++) {
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(x + (p + 1) * 10, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x + p * 10, y);
                        ctx.lineTo(x + (p + 1) * 10, y);
                        ctx.stroke();
                    }
                }
                
                // Water molecules
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    ctx.fillStyle = 'rgba(147, 197, 253, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
            } else if (zoomLevel === 'organelle') {
                // Draw detailed organelles
                
                // Cell membrane (more detailed)
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 170, 140, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Nucleus with nucleolus
                const nucleusGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 50);
                nucleusGradient.addColorStop(0, 'rgba(102, 126, 234, 0.8)');
                nucleusGradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.5)');
                nucleusGradient.addColorStop(1, 'rgba(102, 126, 234, 0.2)');
                ctx.fillStyle = nucleusGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY - 20, 50, 0, Math.PI * 2);
                ctx.fill();
                
                // Nuclear pores
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * 45;
                    const y = centerY - 20 + Math.sin(angle) * 45;
                    ctx.fillStyle = '#4c1d95';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Nucleolus
                ctx.fillStyle = 'rgba(76, 29, 149, 0.7)';
                ctx.beginPath();
                ctx.arc(centerX + 10, centerY - 25, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Mitochondria (with cristae)
                const mitochondria = [
                    { x: centerX - 80, y: centerY + 30, w: 40, h: 20, angle: 0.3 },
                    { x: centerX + 70, y: centerY - 60, w: 35, h: 18, angle: -0.4 },
                    { x: centerX + 90, y: centerY + 50, w: 38, h: 19, angle: 0.2 }
                ];
                
                mitochondria.forEach(mito => {
                    ctx.save();
                    ctx.translate(mito.x, mito.y);
                    ctx.rotate(mito.angle);
                    
                    // Outer membrane
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, mito.w, mito.h, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cristae (internal folds)
                    ctx.strokeStyle = '#7c3aed';
                    ctx.lineWidth = 1.5;
                    for (let i = -mito.w + 10; i < mito.w - 10; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(i, -mito.h * 0.6);
                        ctx.quadraticCurveTo(i + 4, 0, i, mito.h * 0.6);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
                
                // Endoplasmic reticulum (rough with ribosomes)
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - 120, centerY - 80);
                ctx.bezierCurveTo(
                    centerX - 80, centerY - 60,
                    centerX - 40, centerY - 90,
                    centerX, centerY - 70
                );
                ctx.bezierCurveTo(
                    centerX + 40, centerY - 50,
                    centerX + 80, centerY - 80,
                    centerX + 120, centerY - 60
                );
                ctx.stroke();
                
                // Ribosomes on ER
                for (let i = 0; i < 15; i++) {
                    const t = i / 15;
                    const x = centerX - 120 + t * 240;
                    const y = centerY - 75 + Math.sin(t * Math.PI * 2) * 15;
                    ctx.fillStyle = '#7c2d12';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Golgi apparatus (stacked cisternae)
                ctx.save();
                ctx.translate(centerX - 60, centerY + 70);
                for (let i = 0; i < 5; i++) {
                    ctx.strokeStyle = `rgba(249, 115, 22, ${0.8 - i * 0.1})`;
                    ctx.lineWidth = 3 - i * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, i * 6);
                    ctx.bezierCurveTo(
                        20, i * 6 - 5,
                        40, i * 6 + 5,
                        60, i * 6
                    );
                    ctx.stroke();
                }
                ctx.restore();
                
                // Lysosomes
                for (let i = 0; i < 4; i++) {
                    const x = centerX + Math.random() * 100 - 50;
                    const y = centerY + Math.random() * 100 - 50;
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Digestive enzymes
                    for (let j = 0; j < 3; j++) {
                        ctx.fillStyle = '#7f1d1d';
                        ctx.beginPath();
                        ctx.arc(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Cytoskeleton filaments
                ctx.strokeStyle = 'rgba(147, 51, 234, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    const startX = Math.random() * ctx.canvas.width;
                    const startY = Math.random() * ctx.canvas.height;
                    const endX = startX + Math.random() * 100 - 50;
                    const endY = startY + Math.random() * 100 - 50;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
            } else {
                // Full cell view with all components visible
                
                // Cell membrane with lipid bilayer detail
                ctx.strokeStyle = '#4c1d95';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 150, 120, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner membrane layer
                ctx.strokeStyle = '#6d28d9';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 145, 115, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Nucleus
                ctx.fillStyle = 'rgba(102, 126, 234, 0.4)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 45, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Nucleolus
                ctx.fillStyle = 'rgba(76, 29, 149, 0.6)';
                ctx.beginPath();
                ctx.arc(centerX + 10, centerY - 5, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Mitochondria
                const mitoPositions = [
                    { x: -70, y: 30, r: 15 },
                    { x: 60, y: -40, r: 12 },
                    { x: 80, y: 40, r: 13 },
                    { x: -50, y: -50, r: 11 }
                ];
                
                mitoPositions.forEach(pos => {
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(centerX + pos.x, centerY + pos.y, pos.r * 1.5, pos.r, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // ER network
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - 100, centerY - 60);
                ctx.quadraticCurveTo(centerX - 50, centerY - 40, centerX, centerY - 50);
                ctx.quadraticCurveTo(centerX + 50, centerY - 60, centerX + 100, centerY - 40);
                ctx.stroke();
                
                // Golgi
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.6)';
                ctx.lineWidth = 3;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(centerX - 80, centerY + 50 + i * 5);
                    ctx.lineTo(centerX - 40, centerY + 50 + i * 5);
                    ctx.stroke();
                }
                
                // Lysosomes and vesicles
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 60 + Math.random() * 40;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.fillStyle = i < 4 ? 'rgba(239, 68, 68, 0.5)' : 'rgba(147, 51, 234, 0.4)';
                    ctx.beginPath();
                    ctx.arc(x, y, 5 + Math.random() * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Cytoplasm dots
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 140;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    // Check if inside cell
                    const ellipseCheck = Math.pow((x - centerX) / 150, 2) + Math.pow((y - centerY) / 120, 2);
                    if (ellipseCheck < 1) {
                        ctx.fillStyle = 'rgba(147, 197, 253, 0.2)';
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function zoomToMolecular() {
            const ctx = document.getElementById('cellCanvas').getContext('2d');
            drawCell(ctx, 'molecular');
        }

        function zoomToOrganelle() {
            const ctx = document.getElementById('cellCanvas').getContext('2d');
            drawCell(ctx, 'organelle');
        }

        function zoomToCell() {
            const ctx = document.getElementById('cellCanvas').getContext('2d');
            drawCell(ctx, 'cell');
        }

        // Touch event handlers for mobile swipe navigation
        function handleTouchStart(e) {
            // Ignore touches on interactive elements
            if (e.target.tagName === 'BUTTON' ||
                e.target.tagName === 'INPUT' ||
                e.target.tagName === 'CANVAS' ||
                e.target.classList.contains('nav-btn')) {
                return;
            }

            const currentSlideEl = document.getElementById(`slide${currentSlide}`);
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            touchEndX = touchStartX;
            touchEndY = touchStartY;
            isSwiping = false;

            // Store initial scroll position
            currentSlideEl.dataset.scrollStart = currentSlideEl.scrollTop;
        }

        function handleTouchMove(e) {
            if (!touchStartX || !touchStartY) {
                return;
            }

            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;

            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            const currentSlideEl = document.getElementById(`slide${currentSlide}`);

            // Check if slide is scrollable
            const isScrollable = currentSlideEl.scrollHeight > currentSlideEl.clientHeight;
            const isAtTop = currentSlideEl.scrollTop <= 0;
            const isAtBottom = currentSlideEl.scrollTop + currentSlideEl.clientHeight >= currentSlideEl.scrollHeight - 5;

            // Determine gesture type early
            if (!isSwiping && Math.abs(diffX) > scrollThreshold) {
                const isHorizontalSwipe = Math.abs(diffX) > Math.abs(diffY) * 1.5;

                if (isHorizontalSwipe) {
                    isSwiping = true;
                    // Prevent default only for horizontal swipes
                    if (!isScrollable || (isAtTop && diffY <= 0) || (isAtBottom && diffY >= 0)) {
                        e.preventDefault();
                    }
                }
            }

            // Visual feedback for swipe
            if (isSwiping && Math.abs(diffX) > 30) {
                currentSlideEl.style.transform = `translateX(${diffX * 0.2}px)`;
                currentSlideEl.style.opacity = `${1 - Math.abs(diffX) / 500}`;
            }
        }

        function handleTouchEnd(e) {
            if (!touchStartX || !touchStartY) {
                return;
            }

            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            const currentSlideEl = document.getElementById(`slide${currentSlide}`);

            // Reset visual feedback
            currentSlideEl.style.transform = '';
            currentSlideEl.style.opacity = '';

            // Check if it's a valid horizontal swipe
            if (isSwiping && Math.abs(diffX) > swipeThreshold && Math.abs(diffX) > Math.abs(diffY) * 1.2) {
                if (diffX > 0 && currentSlide > 1) {
                    // Swipe right - go to previous slide
                    previousSlide();
                } else if (diffX < 0 && currentSlide < totalSlides) {
                    // Swipe left - go to next slide
                    nextSlide();
                }
            }

            // Reset values
            touchStartX = 0;
            touchStartY = 0;
            touchEndX = 0;
            touchEndY = 0;
            isSwiping = false;
        }

        // Add touch event listeners
        document.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: true });

        // Prevent default touch behavior on interactive elements
        const preventDefaultOnInteractive = (e) => {
            const target = e.target;
            if (target.tagName === 'BUTTON' ||
                target.tagName === 'INPUT' ||
                target.tagName === 'CANVAS' ||
                target.classList.contains('nav-btn')) {
                e.stopPropagation();
            }
        };

        document.addEventListener('touchstart', preventDefaultOnInteractive, { passive: true });

        // Improve touch responsiveness for buttons
        document.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                this.click();
            }, { passive: false });
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                const currentSlideEl = document.getElementById(`slide${currentSlide}`);
                if (currentSlideEl) {
                    currentSlideEl.scrollTop = 0;
                }
                initializeSlide(currentSlide);
            }, 100);
        });

        // Handle resize for responsive canvas
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initializeSlide(currentSlide);
            }, 250);
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // If on first slide and navigation not yet visible, show it immediately on any arrow key
            if (currentSlide === 1 && navigationTimeout && (e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
                clearTimeout(navigationTimeout);
                navigationTimeout = null;
                showNavigation();
            }
            
            if (e.key === 'ArrowRight' && currentSlide < totalSlides) {
                nextSlide();
            }
            if (e.key === 'ArrowLeft' && currentSlide > 1) {
                previousSlide();
            }
        });
        
        // Initialize navigation buttons once DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updateNavButtons();
                // Fade in navigation on first slide after delay
                if (currentSlide === 1) {
                    navigationTimeout = setTimeout(() => {
                        showNavigation();
                        navigationTimeout = null;
                    }, 3000); // 3 second delay
                }
            });
        } else {
            // Delay slightly to ensure DOM is fully constructed
            setTimeout(() => {
                updateNavButtons();
                // Fade in navigation on first slide after delay
                if (currentSlide === 1) {
                    navigationTimeout = setTimeout(() => {
                        showNavigation();
                        navigationTimeout = null;
                    }, 2000); // 2 second delay
                }
            }, 0);
        }

        // Ensure first slide is visible and others are properly hidden
        document.getElementById('slide1').style.display = 'flex';
        document.getElementById('slide1').classList.add('active');
        for (let i = 2; i <= totalSlides; i++) {
            const slide = document.getElementById(`slide${i}`);
            if (slide) {
                slide.style.display = 'none';
                slide.classList.remove('active');
            }
        }
    </script>
</body>
</html>
